{"version":3,"sources":["../lib/constants.js","../lib/mergeRefTokens.js","../lib/lexers/lexError.js","../lib/lexers/lexRangeTrim.js","../lib/lexers/lexOperator.js","../lib/lexers/lexFunction.js","../lib/lexers/lexBoolean.js","../lib/lexers/lexNewLine.js","../lib/lexers/lexWhitespace.js","../lib/lexers/lexString.js","../lib/lexers/lexContext.js","../lib/lexers/advRangeOp.js","../lib/lexers/canEndRange.js","../lib/lexers/lexRangeA1.js","../lib/lexers/lexRangeR1C1.js","../lib/lexers/lexRange.js","../lib/parseSRange.js","../lib/lexers/lexStructured.js","../lib/lexers/lexNumber.js","../lib/lexers/lexNamed.js","../lib/lexers/lexRefOp.js","../lib/lexers/sets.js","../lib/lexer.js","../lib/isType.js","../lib/parser.js","../lib/parseRef.js","../lib/toCol.js","../lib/stringifyPrefix.js","../lib/fromA1.js","../lib/a1.js","../lib/parseStructRef.js","../lib/addTokenMeta.js","../lib/rc.js","../lib/translate.js","../lib/stringifyStructRef.js","../lib/fixRanges.js","../lib/fromCol.js","../lib/index.js"],"sourcesContent":["export const OPERATOR = 'operator';\nexport const OPERATOR_TRIM = 'operator-trim';\nexport const BOOLEAN = 'bool';\nexport const ERROR = 'error';\nexport const NUMBER = 'number';\nexport const FUNCTION = 'func';\nexport const NEWLINE = 'newline';\nexport const WHITESPACE = 'whitespace';\nexport const STRING = 'string';\nexport const CONTEXT_QUOTE = 'context_quote';\nexport const CONTEXT = 'context';\nexport const REF_RANGE = 'range';\nexport const REF_BEAM = 'range_beam';\nexport const REF_TERNARY = 'range_ternary';\nexport const REF_NAMED = 'range_named';\nexport const REF_STRUCT = 'structured';\nexport const FX_PREFIX = 'fx_prefix';\nexport const UNKNOWN = 'unknown';\n\nexport const UNARY = 'UnaryExpression';\nexport const BINARY = 'BinaryExpression';\nexport const REFERENCE = 'ReferenceIdentifier';\nexport const LITERAL = 'Literal';\nexport const ERROR_LITERAL = 'ErrorLiteral';\nexport const CALL = 'CallExpression';\nexport const LAMBDA = 'LambdaExpression';\nexport const LET = 'LetExpression';\nexport const ARRAY = 'ArrayExpression';\nexport const IDENTIFIER = 'Identifier';\nexport const LET_DECL = 'LetDeclarator';\n\nexport const MAX_COLS = (2 ** 14) - 1; // 16383\nexport const MAX_ROWS = (2 ** 20) - 1; // 1048575\n","import { CONTEXT, CONTEXT_QUOTE, REF_RANGE, REF_NAMED, REF_BEAM, REF_TERNARY, OPERATOR, REF_STRUCT } from './constants.js';\n\nconst END = '$';\n\nconst validRunsMerge = [\n  [ REF_RANGE, ':', REF_RANGE ],\n  [ REF_RANGE, '.:', REF_RANGE ],\n  [ REF_RANGE, ':.', REF_RANGE ],\n  [ REF_RANGE, '.:.', REF_RANGE ],\n  [ REF_RANGE ],\n  [ REF_BEAM ],\n  [ REF_TERNARY ],\n  [ CONTEXT, '!', REF_RANGE, ':', REF_RANGE ],\n  [ CONTEXT, '!', REF_RANGE, '.:', REF_RANGE ],\n  [ CONTEXT, '!', REF_RANGE, ':.', REF_RANGE ],\n  [ CONTEXT, '!', REF_RANGE, '.:.', REF_RANGE ],\n  [ CONTEXT, '!', REF_RANGE ],\n  [ CONTEXT, '!', REF_BEAM ],\n  [ CONTEXT, '!', REF_TERNARY ],\n  [ CONTEXT_QUOTE, '!', REF_RANGE, ':', REF_RANGE ],\n  [ CONTEXT_QUOTE, '!', REF_RANGE, '.:', REF_RANGE ],\n  [ CONTEXT_QUOTE, '!', REF_RANGE, ':.', REF_RANGE ],\n  [ CONTEXT_QUOTE, '!', REF_RANGE, '.:.', REF_RANGE ],\n  [ CONTEXT_QUOTE, '!', REF_RANGE ],\n  [ CONTEXT_QUOTE, '!', REF_BEAM ],\n  [ CONTEXT_QUOTE, '!', REF_TERNARY ],\n  [ REF_NAMED ],\n  [ CONTEXT, '!', REF_NAMED ],\n  [ CONTEXT_QUOTE, '!', REF_NAMED ],\n  [ REF_STRUCT ],\n  [ REF_NAMED, REF_STRUCT ],\n  [ CONTEXT, '!', REF_NAMED, REF_STRUCT ],\n  [ CONTEXT_QUOTE, '!', REF_NAMED, REF_STRUCT ]\n];\n\n// valid token runs are converted to a tree structure\nconst refPartsTree = {};\nfunction packList (f, node) {\n  if (f.length) {\n    const key = f[0];\n    node[key] = node[key] || {};\n    packList(f.slice(1), node[key]);\n  }\n  else {\n    node[END] = true;\n  }\n}\nvalidRunsMerge.forEach(run => packList(run.concat().reverse(), refPartsTree));\n\n// attempt to match a backwards run of tokens from a given point\n// to a path in the tree\nconst matcher = (tokens, currNode, anchorIndex, index = 0) => {\n  let i = index;\n  let node = currNode;\n  const max = tokens.length - index;\n  // keep walking as long as the next backward token matches a child key\n  while (i <= max) {\n    const token = tokens[anchorIndex - i];\n    if (token) {\n      const key = (token.type === OPERATOR) ? token.value : token.type;\n      if (key in node) {\n        node = node[key];\n        i += 1;\n        continue;\n      }\n    }\n    // can't advance further; accept only if current node is a terminal\n    return node[END] ? i : 0;\n  }\n};\n\n/**\n * Merges context with reference tokens as possible in a list of tokens.\n *\n * When given a tokenlist, this function returns a new list with ranges returned\n * as whole references (`Sheet1!A1:B2`) rather than separate tokens for each\n * part: (`Sheet1`,`!`,`A1`,`:`,`B2`).\n *\n * @param {Array<Token>} tokenlist An array of tokens (from `tokenize()`)\n * @returns {Array<Token>} A new list of tokens with range parts merged.\n */\nexport function mergeRefTokens (tokenlist) {\n  const finalTokens = [];\n  // this seeks backwards because it's really the range part\n  // that controls what can be joined.\n  for (let i = tokenlist.length - 1; i >= 0; i--) {\n    let token = tokenlist[i];\n    const type = token.type;\n    // Quick check if token type could even start a valid run\n    if (type === REF_RANGE || type === REF_BEAM || type === REF_TERNARY ||\n        type === REF_NAMED || type === REF_STRUCT) {\n      const valid = matcher(tokenlist, refPartsTree, i);\n      if (valid > 1) {\n        token = { ...token, value: '' };\n        const start = i - valid + 1;\n        for (let j = start; j <= i; j++) {\n          token.value += tokenlist[j].value;\n        }\n        // adjust the offsets to include all the text\n        if (token.loc && tokenlist[start].loc) {\n          token.loc[0] = tokenlist[start].loc[0];\n        }\n        i -= valid - 1;\n      }\n    }\n    finalTokens[finalTokens.length] = token;\n  }\n  return finalTokens.reverse();\n}\n","/* eslint-disable no-mixed-operators */\nimport { ERROR } from '../constants.js';\n\nconst re_ERROR = /#(?:NAME\\?|FIELD!|CALC!|VALUE!|REF!|DIV\\/0!|NULL!|NUM!|N\\/A|GETTING_DATA\\b|SPILL!|UNKNOWN!|SYNTAX\\?|ERROR!|CONNECT!|BLOCKED!|EXTERNAL!)/iy;\nconst HASH = 35;\n\nexport function lexError (str, pos) {\n  if (str.charCodeAt(pos) === HASH) {\n    re_ERROR.lastIndex = pos;\n    const m = re_ERROR.exec(str);\n    if (m) {\n      return { type: ERROR, value: m[0] };\n    }\n  }\n}\n","import { OPERATOR_TRIM } from '../constants.js';\n\nconst PERIOD = 46;\nconst COLON = 58;\n\nexport function lexRangeTrim (str, pos) {\n  const c0 = str.charCodeAt(pos);\n  if (c0 === PERIOD || c0 === COLON) {\n    const c1 = str.charCodeAt(pos + 1);\n    if (c0 !== c1) {\n      if (c1 === COLON) {\n        return {\n          type: OPERATOR_TRIM,\n          value: str.slice(pos, pos + (str.charCodeAt(pos + 2) === PERIOD ? 3 : 2))\n        };\n      }\n      else if (c1 === PERIOD) {\n        return {\n          type: OPERATOR_TRIM,\n          value: str.slice(pos, pos + 2)\n        };\n      }\n    }\n  }\n}\n","import { OPERATOR } from '../constants.js';\n\nexport function lexOperator (str, pos) {\n  const c0 = str.charCodeAt(pos);\n  const c1 = str.charCodeAt(pos + 1);\n  if (\n    (c0 === 60 && c1 === 61) || // <=\n    (c0 === 62 && c1 === 61) || // >=\n    (c0 === 60 && c1 === 62)    // <>\n  ) {\n    return { type: OPERATOR, value: str.slice(pos, pos + 2) };\n  }\n  if (\n    // { } ! # % &\n    c0 === 123 || c0 === 125 || c0 === 33 || c0 === 35 || c0 === 37 || c0 === 38 ||\n    // ( ) * + , -\n    c0 === 40 || c0 === 41 || c0 === 42 || c0 === 43 || c0 === 44 || c0 === 45 ||\n    // / : ; < = >\n    c0 === 47 || c0 === 58 || c0 === 59 || c0 === 60 || c0 === 61 || c0 === 62 ||\n    // @ ^\n    c0 === 64 || c0 === 94\n  ) {\n    return { type: OPERATOR, value: str[pos] };\n  }\n}\n","import { FUNCTION } from '../constants.js';\n\nconst PAREN_OPEN = 40;\n\n// [A-Za-z_]+[A-Za-z\\d_.]*(?=\\()\nexport function lexFunction (str, pos) {\n  const start = pos;\n  // starts with: a-zA-Z_\n  let c = str.charCodeAt(pos);\n  if (\n    (c < 65 || c > 90) && // A-Z\n    (c < 97 || c > 122) && // a-z\n    (c !== 95) // _\n  ) {\n    return;\n  }\n  pos++;\n  // has any number of: a-zA-Z0-9_.\n  do {\n    c = str.charCodeAt(pos);\n    if (\n      (c < 65 || c > 90) && // A-Z\n      (c < 97 || c > 122) && // a-z\n      (c < 48 || c > 57) && // 0-9\n      (c !== 95) && // _\n      (c !== 46) // .\n    ) {\n      break;\n    }\n    pos++;\n  } while (pos < str.length);\n  // followed by a (\n  if (str.charCodeAt(pos) === PAREN_OPEN) {\n    return { type: FUNCTION, value: str.slice(start, pos) };\n  }\n}\n","import { BOOLEAN } from '../constants.js';\n\nexport function lexBoolean (str, pos) {\n  // \"true\" (case insensitive)\n  const c0 = str.charCodeAt(pos);\n  if (c0 === 84 || c0 === 116) {\n    const c1 = str.charCodeAt(pos + 1);\n    if (c1 === 82 || c1 === 114) {\n      const c2 = str.charCodeAt(pos + 2);\n      if (c2 === 85 || c2 === 117) {\n        const c3 = str.charCodeAt(pos + 3);\n        if (c3 === 69 || c3 === 101) {\n          // non char to follow?\n          return { type: BOOLEAN, value: str.slice(pos, pos + 4) };\n        }\n      }\n    }\n  }\n  // \"false\" (case insensitive)\n  if (c0 === 70 || c0 === 102) {\n    const c1 = str.charCodeAt(pos + 1);\n    if (c1 === 65 || c1 === 97) {\n      const c2 = str.charCodeAt(pos + 2);\n      if (c2 === 76 || c2 === 108) {\n        const c3 = str.charCodeAt(pos + 3);\n        if (c3 === 83 || c3 === 115) {\n          const c4 = str.charCodeAt(pos + 4);\n          if (c4 === 69 || c4 === 101) {\n            // non char to follow?\n            return { type: BOOLEAN, value: str.slice(pos, pos + 5) };\n          }\n        }\n      }\n    }\n  }\n}\n","import { NEWLINE } from '../constants.js';\n\nexport function lexNewLine (str, pos) {\n  const start = pos;\n  while (str.charCodeAt(pos) === 10) {\n    pos++;\n  }\n  if (pos !== start) {\n    return { type: NEWLINE, value: str.slice(start, pos) };\n  }\n}\n","import { WHITESPACE } from '../constants.js';\n\nexport function isWS (c) {\n  return (\n    c === 0x9 ||\n    c === 0xB ||\n    c === 0xC ||\n    c === 0xD ||\n    c === 0x20 ||\n    c === 0xA0 ||\n    c === 0x1680 ||\n    c === 0x2028 ||\n    c === 0x2029 ||\n    c === 0x202f ||\n    c === 0x205f ||\n    c === 0x3000 ||\n    c === 0xfeff ||\n    (c >= 0x2000 && c <= 0x200a)\n  );\n}\n\nexport function lexWhitespace (str, pos) {\n  const start = pos;\n  while (isWS(str.charCodeAt(pos))) {\n    pos++;\n  }\n  if (pos !== start) {\n    return { type: WHITESPACE, value: str.slice(start, pos) };\n  }\n}\n","/* eslint-disable no-mixed-operators */\nimport { STRING } from '../constants.js';\n\nconst QUOT = 34;\n\nexport function lexString (str, pos) {\n  const start = pos;\n  if (str.charCodeAt(pos) === QUOT) {\n    pos++;\n    while (pos < str.length) {\n      const c = str.charCodeAt(pos);\n      if (c === QUOT) {\n        pos++;\n        if (str.charCodeAt(pos) !== QUOT) {\n          return { type: STRING, value: str.slice(start, pos) };\n        }\n      }\n      pos++;\n    }\n    return { type: STRING, value: str.slice(start, pos), unterminated: true };\n  }\n}\n","import { CONTEXT, CONTEXT_QUOTE } from '../constants.js';\n\nconst QUOT_SINGLE = 39; // '\nconst BR_OPEN = 91; // [\nconst BR_CLOSE = 93; // ]\nconst EXCL = 33; // !\n\n// xlsx xml uses a variant of the syntax that has external references in\n// bracets. Any of: [1]Sheet1!A1, '[1]Sheet one'!A1, [1]!named\nexport function lexContext (str, pos, options) {\n  const c0 = str.charCodeAt(pos);\n  let br1;\n  let br2;\n  // quoted context: '(?:''|[^'])*('|$)(?=!)\n  if (c0 === QUOT_SINGLE) {\n    const start = pos;\n    pos++;\n    while (pos < str.length) {\n      const c = str.charCodeAt(pos);\n      if (c === BR_OPEN) {\n        if (br1) { return; } // only 1 allowed\n        br1 = pos;\n      }\n      else if (c === BR_CLOSE) {\n        if (br2) { return; } // only 1 allowed\n        br2 = pos;\n      }\n      else if (c === QUOT_SINGLE) {\n        pos++;\n        if (str.charCodeAt(pos) !== QUOT_SINGLE) {\n          let valid = br1 == null && br2 == null;\n          if (options.xlsx && (br1 === start + 1) && (br2 === pos - 2)) {\n            valid = true;\n          }\n          if ((br1 >= start + 1) && (br2 < pos - 2) && (br2 > br1 + 1)) {\n            valid = true;\n          }\n          if (valid && str.charCodeAt(pos) === EXCL) {\n            return { type: CONTEXT_QUOTE, value: str.slice(start, pos) };\n          }\n          return;\n        }\n      }\n      pos++;\n    }\n  }\n  // unquoted context\n  else if (c0 !== EXCL) {\n    const start = pos;\n    while (pos < str.length) {\n      const c = str.charCodeAt(pos);\n      if (c === BR_OPEN) {\n        if (br1) { return; } // only 1 allowed\n        br1 = pos;\n      }\n      else if (c === BR_CLOSE) {\n        if (br2) { return; } // only 1 allowed\n        br2 = pos;\n      }\n      else if (c === EXCL) {\n        let valid = br1 == null && br2 == null;\n        if (options.xlsx && (br1 === start) && (br2 === pos - 1)) {\n          valid = true;\n        }\n        if ((br1 >= start) && (br2 < pos - 1) && (br2 > br1 + 1)) {\n          valid = true;\n        }\n        if (valid) {\n          return { type: CONTEXT, value: str.slice(start, pos) };\n        }\n      }\n      else if (\n        (br1 == null || br2 != null) &&\n        // [0-9A-Za-z._¡¤§¨ª\\u00ad¯-\\uffff]\n        !(\n          (c >= 65 && c <= 90) || // A-Z\n          (c >= 97 && c <= 122) || // a-z\n          (c >= 48 && c <= 57) || // 0-9\n          (c === 46) || // .\n          (c === 95) || // _\n          (c === 161) || // ¡\n          (c === 164) || // ¤\n          (c === 167) || // §\n          (c === 168) || // ¨\n          (c === 170) || // ª\n          (c === 173) || // \\u00ad\n          (c >= 175)    // ¯-\\uffff\n        )\n      ) {\n        return;\n      }\n      // 0-9A-Za-z._¡¤§¨ª\\u00ad¯-\\uffff\n      pos++;\n    }\n  }\n}\n","const PERIOD = 46;\nconst COLON = 58;\n\nexport function advRangeOp (str, pos) {\n  const c0 = str.charCodeAt(pos);\n  if (c0 === PERIOD) {\n    const c1 = str.charCodeAt(pos + 1);\n    if (c1 === COLON) {\n      return str.charCodeAt(pos + 2) === PERIOD ? 3 : 2;\n    }\n  }\n  else if (c0 === COLON) {\n    const c1 = str.charCodeAt(pos + 1);\n    return c1 === PERIOD ? 2 : 1;\n  }\n  return 0;\n}\n\n","// regular: [A-Za-z0-9_\\u00a1-\\uffff]\nexport function canEndRange (str, pos) {\n  const c = str.charCodeAt(pos);\n  return !(\n    (c >= 65 && c <= 90) || // A-Z\n    (c >= 97 && c <= 122) || // a-z\n    (c >= 48 && c <= 57) || // 0-9\n    (c === 95) || // _\n    (c > 0xA0) // \\u00a1-\\uffff\n  );\n}\n\n// partial: [A-Za-z0-9_($.]\nexport function canEndPartialRange (str, pos) {\n  const c = str.charCodeAt(pos);\n  return !(\n    (c >= 65 && c <= 90) || // A-Z\n    (c >= 97 && c <= 122) || // a-z\n    (c >= 48 && c <= 57) || // 0-9\n    (c === 95) || // _\n    (c === 40) || // (\n    (c === 36) || // $\n    (c === 46) // .\n  );\n}\n","/* eslint-disable no-mixed-operators */\nimport { REF_RANGE, REF_BEAM, REF_TERNARY, MAX_COLS, MAX_ROWS } from '../constants.js';\nimport { advRangeOp } from './advRangeOp.js';\nimport { canEndRange, canEndPartialRange } from './canEndRange.js';\n\nfunction advA1Col (str, pos) {\n  // [A-Z]{1,3}\n  const start = pos;\n  if (str.charCodeAt(pos) === 36) { // $\n    pos++;\n  }\n  const stop = pos + 3;\n  let col = 0;\n  do {\n    const c = str.charCodeAt(pos);\n    if (c >= 65 && c <= 90) { // A-Z\n      col = 26 * col + c - 64;\n      pos++;\n    }\n    else if (c >= 97 && c <= 122) { // a-z\n      col = 26 * col + c - 96;\n      pos++;\n    }\n    else {\n      break;\n    }\n  }\n  while (pos < stop && pos < str.length);\n  return (col && col <= MAX_COLS + 1) ? pos - start : 0;\n}\n\nfunction advA1Row (str, pos) {\n  // [1-9][0-9]{0,6}\n  const start = pos;\n  if (str.charCodeAt(pos) === 36) { // $\n    pos++;\n  }\n  const stop = pos + 7;\n  let row = 0;\n  let c = str.charCodeAt(pos);\n  if (c >= 49 && c <= 57) { // 1-9\n    row = row * 10 + c - 48;\n    pos++;\n    do {\n      c = str.charCodeAt(pos);\n      if (c >= 48 && c <= 57) { // 0-9\n        row = row * 10 + c - 48;\n        pos++;\n      }\n      else {\n        break;\n      }\n    }\n    while (pos < stop && pos < str.length);\n  }\n  return (row && row <= MAX_ROWS + 1) ? pos - start : 0;\n}\n\nexport function lexRangeA1 (str, pos, options) {\n  let p = pos;\n  const left = advA1Col(str, p);\n  let right = 0;\n  let bottom = 0;\n  if (left) {\n    // TLBR: could be A1:A1\n    // TL R: could be A1:A (if allowTernary)\n    // TLB : could be A1:1 (if allowTernary)\n    //  LBR: could be A:A1 (if allowTernary)\n    //  L R: could be A:A\n    p += left;\n    const top = advA1Row(str, p);\n    p += top;\n    const op = advRangeOp(str, p);\n    const preOp = p;\n    if (op) {\n      p += op;\n      right = advA1Col(str, p);\n      p += right;\n      bottom = advA1Row(str, p);\n      p += bottom;\n      if (top && bottom && right) {\n        if (canEndRange(str, p) && options.mergeRefs) {\n          return { type: REF_RANGE, value: str.slice(pos, p) };\n        }\n      }\n      else if (!top && !bottom) {\n        if (canEndRange(str, p)) {\n          return { type: REF_BEAM, value: str.slice(pos, p) };\n        }\n      }\n      else if (options.allowTernary && (bottom || right)) {\n        if (canEndPartialRange(str, p)) {\n          return { type: REF_TERNARY, value: str.slice(pos, p) };\n        }\n      }\n    }\n    // LT  : this is A1\n    if (top && canEndRange(str, preOp)) {\n      return { type: REF_RANGE, value: str.slice(pos, preOp) };\n    }\n  }\n  else {\n    // T B : could be 1:1\n    // T BR: could be 1:A1 (if allowTernary)\n    const top = advA1Row(str, p);\n    if (top) {\n      p += top;\n      const op = advRangeOp(str, p);\n      if (op) {\n        p += op;\n        right = advA1Col(str, p);\n        if (right) {\n          p += right;\n        }\n        bottom = advA1Row(str, p);\n        p += bottom;\n        if (right && bottom && options.allowTernary) {\n          if (canEndPartialRange(str, p)) {\n            return { type: REF_TERNARY, value: str.slice(pos, p) };\n          }\n        }\n        if (!right && bottom) {\n          if (canEndRange(str, p)) {\n            return { type: REF_BEAM, value: str.slice(pos, p) };\n          }\n        }\n      }\n    }\n  }\n}\n","/* eslint-disable no-mixed-operators */\nimport { REF_RANGE, REF_BEAM, REF_TERNARY, MAX_COLS, MAX_ROWS } from '../constants.js';\nimport { advRangeOp } from './advRangeOp.js';\nimport { canEndRange } from './canEndRange.js';\n\nconst BR_OPEN = 91; // [\nconst BR_CLOSE = 93; // ]\nconst UC_R = 82;\nconst LC_R = 114;\nconst UC_C = 67;\nconst LC_C = 99;\nconst PLUS = 43;\nconst MINUS = 45;\n\n// C\n// C\\[[+-]?\\d+\\]\n// C[1-9][0-9]{0,4}\n// R\n// R\\[[+-]?\\d+\\]\n// R[1-9][0-9]{0,6}\nfunction lexR1C1Part (str, pos, isRow = false) {\n  const start = pos;\n  const c0 = str.charCodeAt(pos);\n  if ((isRow ? c0 === UC_R || c0 === LC_R : c0 === UC_C || c0 === LC_C)) {\n    pos++;\n    let digits = 0;\n    let value = 0;\n    let stop = str.length;\n    const c1 = str.charCodeAt(pos);\n    let c;\n    let sign = 1;\n    const relative = c1 === BR_OPEN;\n    if (relative) {\n      stop = Math.min(stop, pos + (isRow ? 8 : 6));\n      pos++;\n      // allow +-\n      c = str.charCodeAt(pos);\n      if (c === PLUS || c === MINUS) {\n        pos++;\n        stop++;\n        sign = c === MINUS ? -1 : 1;\n      }\n    }\n    else if (c1 < 49 || c1 > 57 || isNaN(c1)) {\n      // char must be 1-9, or part is either just \"R\" or \"C\"\n      return 1;\n    }\n\n    do {\n      const c = str.charCodeAt(pos);\n      if (c >= 48 && c <= 57) { // 0-9\n        value = value * 10 + c - 48;\n        digits++;\n        pos++;\n      }\n      else {\n        break;\n      }\n    }\n    while (pos < stop);\n\n    const MAX = isRow ? MAX_ROWS : MAX_COLS;\n    if (relative) {\n      const c = str.charCodeAt(pos);\n      if (c !== BR_CLOSE) {\n        return 0;\n      }\n      // isRow: next char must not be a number!\n      pos++;\n      value *= sign;\n      return (digits && (-MAX <= value) && (value <= MAX))\n        ? pos - start\n        : 0;\n    }\n    // isRow: next char must not be a number!\n    return (digits && value <= (MAX + 1)) ? pos - start : 0;\n  }\n  return 0;\n}\n\nexport function lexRangeR1C1 (str, pos, options) {\n  let p = pos;\n  // C1\n  // C1:C1\n  // C1:R1C1  --partial\n  // R1\n  // R1:R1\n  // R1:R1C1  --partial\n  // R1C1\n  // R1C1:C1  --partial\n  // R1C1:R1  --partial\n  const r1 = lexR1C1Part(str, p, true);\n  p += r1;\n  const c1 = lexR1C1Part(str, p);\n  p += c1;\n  if (c1 || r1) {\n    const op = advRangeOp(str, p);\n    const preOp = p;\n    if (op) {\n      p += op;\n      const r2 = lexR1C1Part(str, p, true); // R1\n      p += r2;\n      const c2 = lexR1C1Part(str, p); // C1\n      p += c2;\n\n      // C1:R2C2  --partial\n      // R1:R2C2  --partial\n      // R1C1:C2  --partial\n      // R1C1:R2  --partial\n      if (\n        (r1 && !c1 && r2 && c2) ||\n        (!r1 && c1 && r2 && c2) ||\n        (r1 && c1 && r2 && !c2) ||\n        (r1 && c1 && !r2 && c2)\n      ) {\n        if (options.allowTernary && canEndRange(str, p)) {\n          return { type: REF_TERNARY, value: str.slice(pos, p) };\n        }\n      }\n      // C1:C2 -- beam\n      // R1:R2 -- beam\n      else if (\n        (c1 && c2 && !r1 && !r2) ||\n        (!c1 && !c2 && r1 && r2)\n      ) {\n        if (canEndRange(str, p)) {\n          return { type: REF_BEAM, value: str.slice(pos, p) };\n        }\n      }\n      // Note: we do not capture R1C1:R1C1, mergeRefTokens will join the parts\n    }\n    // R1\n    // C1\n    // R1C1\n    if (canEndRange(str, preOp)) {\n      return {\n        type: (r1 && c1) ? REF_RANGE : REF_BEAM,\n        value: str.slice(pos, preOp)\n      };\n    }\n  }\n}\n","import { lexRangeA1 } from './lexRangeA1.js';\nimport { lexRangeR1C1 } from './lexRangeR1C1.js';\n\nexport function lexRange (str, pos, options) {\n  return options.r1c1\n    ? lexRangeR1C1(str, pos, options)\n    : lexRangeA1(str, pos, options);\n}\n","import { isWS } from './lexers/lexWhitespace.js';\n\nconst AT = 64; // @\nconst BR_CLOSE = 93; // ]\nconst BR_OPEN = 91; // [\nconst COLON = 58; // :\nconst COMMA = 44; // ,\nconst HASH = 35; // #\nconst QUOT_SINGLE = 39; // '\n\nconst keyTerms = {\n  'headers': 1,\n  'data': 2,\n  'totals': 4,\n  'all': 8,\n  'this row': 16,\n  '@': 16\n};\n\n// only combinations allowed are: #data + (#headers | #totals | #data)\nconst fz = (...a) => Object.freeze(a);\nconst sectionMap = {\n  // no terms\n  0: fz(),\n  // single term\n  1: fz('headers'),\n  2: fz('data'),\n  4: fz('totals'),\n  8: fz('all'),\n  16: fz('this row'),\n  // headers+data\n  3: fz('headers', 'data'),\n  // totals+data\n  6: fz('data', 'totals')\n};\n\nfunction matchKeyword (str, pos) {\n  let p = pos;\n  if (str.charCodeAt(p++) !== BR_OPEN) {\n    return;\n  }\n  if (str.charCodeAt(p++) !== HASH) {\n    return;\n  }\n  do {\n    const c = str.charCodeAt(p);\n    if (\n      (c >= 65 && c <= 90) || // A-Z\n      (c >= 97 && c <= 122) || // a-z\n      (c === 32) // space\n    ) {\n      p++;\n    }\n    else {\n      break;\n    }\n  }\n  while (p < pos + 11); // max length: '[#this row'\n  if (str.charCodeAt(p++) !== BR_CLOSE) {\n    return;\n  }\n  return p - pos;\n}\n\nfunction skipWhitespace (str, pos) {\n  let p = pos;\n  while (isWS(str.charCodeAt(p))) { p++; }\n  return p - pos;\n}\n\nfunction matchColumn (str, pos, allowUnbraced = true) {\n  let p = pos;\n  let column = '';\n  if (str.charCodeAt(p) === BR_OPEN) {\n    p++;\n    let c;\n    do {\n      c = str.charCodeAt(p);\n      if (c === QUOT_SINGLE) {\n        p++;\n        c = str.charCodeAt(p);\n        // Allowed set: '#@[]\n        if (c === QUOT_SINGLE || c === HASH || c === AT || c === BR_OPEN || c === BR_CLOSE) {\n          column += String.fromCharCode(c);\n          p++;\n        }\n        else {\n          return;\n        }\n      }\n      // Allowed set is all chars BUT: '#@[]\n      else if (c === QUOT_SINGLE || c === HASH || c === AT || c === BR_OPEN) {\n        return;\n      }\n      else if (c === BR_CLOSE) {\n        p++;\n        return [ str.slice(pos, p), column ];\n      }\n      else {\n        column += String.fromCharCode(c);\n        p++;\n      }\n    }\n    while (p < str.length);\n  }\n  else if (allowUnbraced) {\n    let c;\n    do {\n      c = str.charCodeAt(p);\n      // Allowed set is all chars BUT: '#@[]:\n      if (c === QUOT_SINGLE || c === HASH || c === AT || c === BR_OPEN || c === BR_CLOSE || c === COLON) {\n        break;\n      }\n      else {\n        column += String.fromCharCode(c);\n        p++;\n      }\n    }\n    while (p < str.length);\n    if (p !== pos) {\n      return [ column, column ];\n    }\n  }\n}\n\nexport function parseSRange (str, pos = 0) {\n  const columns = [];\n  const start = pos;\n  let m;\n  let terms = 0;\n\n  // structured refs start with a [\n  if (str.charCodeAt(pos) !== BR_OPEN) {\n    return;\n  }\n\n  // simple keyword: [#keyword]\n  if ((m = matchKeyword(str, pos))) {\n    const k = str.slice(pos + 2, pos + m - 1);\n    pos += m;\n    const term = keyTerms[k.toLowerCase()];\n    if (!term) { return; }\n    terms |= term;\n  }\n  // simple column: [column]\n  else if ((m = matchColumn(str, pos, false))) {\n    pos += m[0].length;\n    if (m[1]) {\n      columns.push(m[1]);\n    }\n  }\n  // use the \"normal\" method\n  // [[#keyword]]\n  // [[column]]\n  // [@]\n  // [@column]\n  // [@[column]]\n  // [@column:column]\n  // [@column:[column]]\n  // [@[column]:column]\n  // [@[column]:[column]]\n  // [column:column]\n  // [column:[column]]\n  // [[column]:column]\n  // [[column]:[column]]\n  // [[#keyword],column]\n  // [[#keyword],column:column]\n  // [[#keyword],[#keyword],column:column]\n  // ...\n  else {\n    let expect_more = true;\n    pos++; // skip open brace\n    pos += skipWhitespace(str, pos);\n    // match keywords as we find them\n    while (expect_more && (m = matchKeyword(str, pos))) {\n      const k = str.slice(pos + 2, pos + m - 1);\n      const term = keyTerms[k.toLowerCase()];\n      if (!term) { return; }\n      terms |= term;\n      pos += m;\n      pos += skipWhitespace(str, pos);\n      expect_more = str.charCodeAt(pos) === COMMA;\n      if (expect_more) {\n        pos++;\n        pos += skipWhitespace(str, pos);\n      }\n    }\n    // is there an @ specifier?\n    if (expect_more && (str.charCodeAt(pos) === AT)) {\n      terms |= keyTerms['@'];\n      pos += 1;\n      expect_more = str.charCodeAt(pos) !== BR_CLOSE;\n    }\n    // not all keyword terms may be combined\n    if (!sectionMap[terms]) {\n      return;\n    }\n    // column definitions\n    const leftCol = expect_more && matchColumn(str, pos, true);\n    if (leftCol) {\n      pos += leftCol[0].length;\n      columns.push(leftCol[1]);\n      if (str.charCodeAt(pos) === COLON) {\n        pos++;\n        const rightCol = matchColumn(str, pos, true);\n        if (rightCol) {\n          pos += rightCol[0].length;\n          columns.push(rightCol[1]);\n        }\n        else {\n          return;\n        }\n      }\n      expect_more = false;\n    }\n    // advance ws\n    pos += skipWhitespace(str, pos);\n    // close the ref\n    if (expect_more || str.charCodeAt(pos) !== BR_CLOSE) {\n      return;\n    }\n    // step over the closing ]\n    pos++;\n  }\n\n  const sections = sectionMap[terms];\n  return {\n    columns,\n    sections: sections ? sections.concat() : sections,\n    length: pos - start,\n    token: str.slice(start, pos)\n  };\n}\n","/* eslint-disable no-mixed-operators */\nimport { parseSRange } from '../parseSRange.js';\nimport { REF_STRUCT } from '../constants.js';\nimport { isWS } from './lexWhitespace.js';\n\nconst EXCL = 33; // !\n\nexport function lexStructured (str, pos) {\n  const structData = parseSRange(str, pos);\n  if (structData && structData.length) {\n    // we have a match for a valid SR\n    let i = structData.length;\n    // skip tailing whitespace\n    while (isWS(str.charCodeAt(pos + i))) {\n      i++;\n    }\n    // and ensure that it isn't followed by a !\n    if (str.charCodeAt(pos + i) !== EXCL) {\n      return {\n        type: REF_STRUCT,\n        value: structData.token\n      };\n    }\n  }\n}\n","import { NUMBER } from '../constants.js';\n\nfunction advDigits (str, pos) {\n  const start = pos;\n  do {\n    const c = str.charCodeAt(pos);\n    if (c < 48 || c > 57) { // 0-9\n      break;\n    }\n    pos++;\n  }\n  while (pos < str.length);\n  return pos - start;\n}\n\n// \\d+(\\.\\d+)?(?:[eE][+-]?\\d+)?\nexport function lexNumber (str, pos) {\n  const start = pos;\n\n  // integer\n  const lead = advDigits(str, pos);\n  if (!lead) { return; }\n  pos += lead;\n\n  // optional fraction part\n  const c0 = str.charCodeAt(pos);\n  if (c0 === 46) { // .\n    pos++;\n    const frac = advDigits(str, pos);\n    if (!frac) { return; }\n    pos += frac;\n  }\n  // optional exponent part\n  const c1 = str.charCodeAt(pos);\n  if (c1 === 69 || c1 === 101) { // E e\n    pos++;\n    const sign = str.charCodeAt(pos);\n    if (sign === 43 || sign === 45) { // + -\n      pos++;\n    }\n    const exp = advDigits(str, pos);\n    if (!exp) { return; }\n    pos += exp;\n  }\n\n  return { type: NUMBER, value: str.slice(start, pos) };\n}\n","/* eslint-disable max-len */\nimport { REF_NAMED } from '../constants.js';\n\n// The advertized named ranges rules are a bit off from what Excel seems to do.\n// In the \"extended range\" of chars, it looks like it allows most things above\n// U+00B0 with the range between U+00A0-U+00AF rather random:\n// /^[a-zA-Z\\\\_¡¤§¨ª\\u00ad¯\\u00b0-\\uffff][a-zA-Z0-9\\\\_.?¡¤§¨ª\\u00ad¯\\u00b0-\\uffff]{0,254}/\n//\n// I've simplified to allowing everything above U+00A1:\n// /^[a-zA-Z\\\\_\\u00a1-\\uffff][a-zA-Z0-9\\\\_.?\\u00a1-\\uffff]{0,254}/\nexport function lexNamed (str, pos) {\n  const start = pos;\n  // starts with: [a-zA-Z\\\\_\\u00a1-\\uffff]\n  const s = str.charCodeAt(pos);\n  if (\n    (s >= 65 && s <= 90) || // A-Z\n    (s >= 97 && s <= 122) || // a-z\n    (s === 95) || // _\n    (s === 92) || // \\\n    (s > 0xA0) // \\u00a1-\\uffff\n  ) {\n    pos++;\n  }\n  else {\n    return;\n  }\n  // has any number of: [a-zA-Z0-9\\\\_.?\\u00a1-\\uffff]\n  let c;\n  do {\n    c = str.charCodeAt(pos);\n    if (\n      (c >= 65 && c <= 90) || // A-Z\n      (c >= 97 && c <= 122) || // a-z\n      (c >= 48 && c <= 57) || // 0-9\n      (c === 95) || // _\n      (c === 92) || // \\\n      (c === 46) || // .\n      (c === 63) || // ?\n      (c > 0xA0) // \\u00a1-\\uffff\n    ) {\n      pos++;\n    }\n    else {\n      break;\n    }\n  } while (isFinite(c));\n\n  const len = pos - start;\n  if (len && len < 255) {\n    // names starting with \\ must be at least 3 char long\n    if (s === 92 && len < 3) {\n      return;\n    }\n    // single characters R and C are forbidden as names\n    if (len === 1 && (s === 114 || s === 82 || s === 99 || s === 67)) {\n      return;\n    }\n    return { type: REF_NAMED, value: str.slice(start, pos) };\n  }\n}\n","import { OPERATOR } from '../constants.js';\nimport { advRangeOp } from './advRangeOp.js';\n\nconst EXCL = 33; // !\n\nexport function lexRefOp (str, pos, opts) {\n  // in R1C1 mode we only allow [ '!' ]\n  if (str.charCodeAt(pos) === EXCL) {\n    return { type: OPERATOR, value: str[pos] };\n  }\n  if (!opts.r1c1) {\n    // in A1 mode we allow [ '!' ] + [ ':', '.:', ':.', '.:.']\n    const opLen = advRangeOp(str, pos);\n    if (opLen) {\n      return { type: OPERATOR, value: str.slice(pos, pos + opLen) };\n    }\n  }\n}\n","import { lexError } from './lexError.js';\nimport { lexRangeTrim } from './lexRangeTrim.js';\nimport { lexOperator } from './lexOperator.js';\nimport { lexFunction } from './lexFunction.js';\nimport { lexBoolean } from './lexBoolean.js';\nimport { lexNewLine } from './lexNewLine.js';\nimport { lexWhitespace } from './lexWhitespace.js';\nimport { lexString } from './lexString.js';\nimport { lexContext } from './lexContext.js';\nimport { lexRange } from './lexRange.js';\nimport { lexStructured } from './lexStructured.js';\nimport { lexNumber } from './lexNumber.js';\nimport { lexNamed } from './lexNamed.js';\nimport { lexRefOp } from './lexRefOp.js';\n\nexport const lexers = [\n  lexError,\n  lexRangeTrim,\n  lexOperator,\n  lexFunction,\n  lexBoolean,\n  lexNewLine,\n  lexWhitespace,\n  lexString,\n  lexContext,\n  lexRange,\n  lexStructured,\n  lexNumber,\n  lexNamed\n];\n\nexport const lexersRefs = [\n  lexRefOp,\n  lexContext,\n  lexRange,\n  lexStructured,\n  lexNamed\n];\n","import {\n  FX_PREFIX,\n  NEWLINE,\n  NUMBER,\n  OPERATOR,\n  REF_NAMED,\n  UNKNOWN,\n  WHITESPACE,\n  FUNCTION,\n  OPERATOR_TRIM,\n  REF_RANGE\n} from './constants.js';\nimport { mergeRefTokens } from './mergeRefTokens.js';\nimport { lexers } from './lexers/sets.js';\n\nconst reLetLambda = /^l(?:ambda|et)$/i;\nconst isType = (t, type) => t && t.type === type;\nconst isTextTokenType = tokenType => tokenType === REF_NAMED || tokenType === FUNCTION;\n\nconst causesBinaryMinus = token => {\n  return !isType(token, OPERATOR) || (\n    token.value === '%' ||\n    token.value === '}' ||\n    token.value === ')' ||\n    token.value === '#'\n  );\n};\n\nfunction fixRCNames (tokens) {\n  let withinCall = 0;\n  let parenDepth = 0;\n  let lastToken;\n  for (const token of tokens) {\n    if (token.type === OPERATOR) {\n      if (token.value === '(') {\n        parenDepth++;\n        if (lastToken.type === FUNCTION) {\n          if (reLetLambda.test(lastToken.value)) {\n            withinCall = parenDepth;\n          }\n        }\n      }\n      else if (token.value === ')') {\n        parenDepth--;\n        if (parenDepth < withinCall) {\n          withinCall = 0;\n        }\n      }\n    }\n    else if (withinCall && token.type === UNKNOWN && /^[rc]$/.test(token.value)) {\n      token.type = REF_NAMED;\n    }\n    lastToken = token;\n  }\n  return tokens;\n}\n\nexport function getTokens (fx, tokenHandlers, options = {}) {\n  const {\n    withLocation = false,\n    mergeRefs = true,\n    negativeNumbers = true\n  } = options;\n  const opts = {\n    withLocation: withLocation,\n    mergeRefs: mergeRefs,\n    allowTernary: options.allowTernary ?? false,\n    negativeNumbers: negativeNumbers,\n    r1c1: options.r1c1 ?? false,\n    xlsx: options.xlsx ?? false\n  };\n\n  const tokens = [];\n  let pos = 0;\n  let letOrLambda = 0;\n  let unknownRC = 0;\n  const trimOps = [];\n\n  let tail0; // last non-whitespace token\n  let tail1; // penultimate non-whitespace token\n  let lastToken; // last token\n  const pushToken = token => {\n    let tokenType = token.type;\n    const isCurrUnknown = tokenType === UNKNOWN;\n    const isLastUnknown = lastToken && lastToken.type === UNKNOWN;\n    if (lastToken && (\n      (isCurrUnknown && isLastUnknown) ||\n      (isCurrUnknown && isTextTokenType(lastToken.type)) ||\n      (isLastUnknown && isTextTokenType(tokenType))\n    )) {\n      // UNKNOWN tokens \"contaminate\" sibling text tokens\n      lastToken.value += token.value;\n      lastToken.type = UNKNOWN;\n      if (withLocation) {\n        lastToken.loc[1] = token.loc[1];\n      }\n    }\n    else {\n      if (tokenType === OPERATOR_TRIM) {\n        trimOps.push(tokens.length);\n        tokenType = UNKNOWN;\n        token.type = UNKNOWN;\n      }\n      // push token as normally\n      tokens[tokens.length] = token;\n      lastToken = token;\n      if (tokenType !== WHITESPACE && tokenType !== NEWLINE) {\n        tail1 = tail0;\n        tail0 = token;\n      }\n    }\n  };\n\n  if (fx.startsWith('=')) {\n    const token = { type: FX_PREFIX, value: '=' };\n    if (withLocation) {\n      token.loc = [ 0, 1 ];\n    }\n    pos++;\n    pushToken(token);\n  }\n\n  const numHandlers = tokenHandlers.length;\n  while (pos < fx.length) {\n    const startPos = pos;\n    let token;\n    for (let i = 0; i < numHandlers; i++) {\n      token = tokenHandlers[i](fx, pos, opts);\n      if (token) {\n        pos += token.value.length;\n        break;\n      }\n    }\n\n    if (!token) {\n      token = {\n        type: UNKNOWN,\n        value: fx[pos]\n      };\n      pos++;\n    }\n    if (withLocation) {\n      token.loc = [ startPos, pos ];\n    }\n\n    // make a note if we found a let/lambda call\n    if (lastToken && token.value === '(' && lastToken.type === FUNCTION) {\n      if (reLetLambda.test(lastToken.value)) {\n        letOrLambda++;\n      }\n    }\n    // make a note if we found a R or C unknown\n    if (token.type === UNKNOWN && token.value.length === 1) {\n      const valLC = token.value.toLowerCase();\n      unknownRC += (valLC === 'r' || valLC === 'c') ? 1 : 0;\n    }\n\n    if (negativeNumbers && token.type === NUMBER) {\n      const last1 = lastToken;\n      // do we have a number preceded by a minus?\n      if (last1?.type === OPERATOR && last1.value === '-') {\n        // missing tail1 means we are at the start of the stream\n        if (\n          !tail1 ||\n          tail1.type === FX_PREFIX ||\n          !causesBinaryMinus(tail1)\n        ) {\n          const minus = tokens.pop();\n          token.value = '-' + token.value;\n          if (token.loc) {\n            // ensure offsets are up to date\n            token.loc[0] = minus.loc[0];\n          }\n          // next step tries to counter the screwing around with the tailing\n          // it should be correct again once we pushToken()\n          tail0 = tail1;\n          lastToken = tokens[tokens.length - 1];\n        }\n      }\n    }\n\n    pushToken(token);\n  }\n\n  // if we encountered both a LAMBDA/LET call, and unknown 'r' or 'c' tokens\n  // we'll turn the unknown tokens into names within the call.\n  if (unknownRC && letOrLambda) {\n    fixRCNames(tokens);\n  }\n\n  // Any OPERATOR_TRIM tokens have been indexed already, they now need to be\n  // either turned into OPERATORs or UNKNOWNs. Trim operators are only allowed\n  // between two REF_RANGE tokens as they are not valid in expressions as full\n  // operators.\n  for (const index of trimOps) {\n    const before = tokens[index - 1];\n    const after = tokens[index + 1];\n    tokens[index].type = (before?.type === REF_RANGE && after?.type === REF_RANGE)\n      ? OPERATOR\n      : UNKNOWN;\n  }\n\n  if (mergeRefs) {\n    return mergeRefTokens(tokens);\n  }\n\n  return tokens;\n}\n\n/**\n * Breaks a string formula into a list of tokens.\n *\n * The returned output will be an array of objects representing the tokens:\n *\n * ```js\n * [\n *   { type: FX_PREFIX, value: '=' },\n *   { type: FUNCTION, value: 'SUM' },\n *   { type: OPERATOR, value: '(' },\n *   { type: REF_RANGE, value: 'A1:B2' },\n *   { type: OPERATOR, value: ')' }\n * ]\n * ```\n *\n * Token types may be found as an Object as the\n * [`tokenTypes` export]{@link tokenTypes} on the package\n * (`import {tokenTypes} from '@borgar/fx';`).\n *\n * To support syntax highlighting as you type, `STRING` tokens are allowed to be\n * \"unterminated\". For example, the incomplete formula `=\"Hello world` would be\n * tokenized as:\n *\n * ```js\n * [\n *   { type: FX_PREFIX, value: '=' },\n *   { type: STRING, value: '\"Hello world', unterminated: true },\n * ]\n * ```\n *\n * @see tokenTypes\n * @param {string} formula An Excel formula string (an Excel expression) or an array of tokens.\n * @param {object} [options={}]  Options\n * @param {boolean} [options.allowTernary=false]  Enables the recognition of ternary ranges in the style of `A1:A` or `A1:1`. These are supported by Google Sheets but not Excel. See: References.md.\n * @param {boolean} [options.negativeNumbers=true]  Merges unary minuses with their immediately following number tokens (`-`,`1`) => `-1` (alternatively these will be unary operations in the tree).\n * @param {boolean} [options.r1c1=false]  Ranges are expected to be in the R1C1 style format rather than the more popular A1 style.\n * @param {boolean} [options.withLocation=true]  Nodes will include source position offsets to the tokens: `{ loc: [ start, end ] }`\n * @param {boolean} [options.mergeRefs=true]  Should ranges be returned as whole references (`Sheet1!A1:B2`) or as separate tokens for each part: (`Sheet1`,`!`,`A1`,`:`,`B2`). This is the same as calling [`mergeRefTokens`](#mergeRefTokens)\n * @param {boolean} [options.xlsx=false]  Enables a `[1]Sheet1!A1` or `[1]!name` syntax form for external workbooks found only in XLSX files.\n * @returns {Array<Token>} An AST of nodes\n */\nexport function tokenize (formula, options = {}) {\n  return getTokens(formula, lexers, options);\n}\n","import {\n  REF_RANGE, REF_BEAM, REF_NAMED, REF_TERNARY, REF_STRUCT,\n  FX_PREFIX, WHITESPACE, NEWLINE,\n  FUNCTION, OPERATOR,\n  ERROR, STRING, NUMBER, BOOLEAN\n} from './constants.js';\n\n/**\n * Determines whether the specified token is a range.\n *\n * Returns `true` if the input is a token that has a type of either REF_RANGE\n * (`A1` or `A1:B2`), REF_TERNARY (`A1:A`, `A1:1`, `1:A1`, or `A:A1`), or\n * REF_BEAM (`A:A` or `1:1`). In all other cases `false` is returned.\n *\n * @param {any} token A token\n * @returns {boolean} True if the specified token is range, False otherwise.\n */\nexport function isRange (token) {\n  return !!token && (\n    token.type === REF_RANGE ||\n    token.type === REF_BEAM ||\n    token.type === REF_TERNARY\n  );\n}\n\n/**\n * Determines whether the specified token is a reference.\n *\n * Returns `true` if the input is a token of type REF_RANGE (`A1` or `A1:B2`),\n * REF_TERNARY (`A1:A`, `A1:1`, `1:A1`, or `A:A1`), REF_BEAM (`A:A` or `1:1`),\n * or REF_NAMED (`myrange`). In all other cases `false` is returned.\n *\n * @param {any} token The token\n * @returns {boolean} True if the specified token is reference, False otherwise.\n */\nexport function isReference (token) {\n  return !!token && (\n    token.type === REF_RANGE ||\n    token.type === REF_BEAM ||\n    token.type === REF_TERNARY ||\n    token.type === REF_STRUCT ||\n    token.type === REF_NAMED\n  );\n}\n\n/**\n * Determines whether the specified token is a literal.\n *\n * Returns `true` if the input is a token of type BOOLEAN (`TRUE` or `FALSE`),\n * ERROR (`#VALUE!`), NUMBER (123.4), or STRING (`\"lorem ipsum\"`). In all other\n * cases `false` is returned.\n *\n * @param {any} token The token\n * @returns {boolean} True if the specified token is literal, False otherwise.\n */\nexport function isLiteral (token) {\n  return !!token && (\n    token.type === BOOLEAN ||\n    token.type === ERROR ||\n    token.type === NUMBER ||\n    token.type === STRING\n  );\n}\n\n/**\n * Determines whether the specified token is an error.\n *\n * Returns `true` if the input is a token of type ERROR (`#VALUE!`). In all\n * other cases `false` is returned.\n *\n * @param {any} token The token\n * @returns {boolean} True if the specified token is error, False otherwise.\n */\nexport function isError (token) {\n  return !!token && token.type === ERROR;\n}\n\n/**\n * Determines whether the specified token is whitespace.\n *\n * Returns `true` if the input is a token of type WHITESPACE (` `) or\n * NEWLINE (`\\n`). In all other cases `false` is returned.\n *\n * @param {any} token The token\n * @returns {boolean} True if the specified token is whitespace, False otherwise.\n */\nexport function isWhitespace (token) {\n  return !!token && (\n    token.type === WHITESPACE ||\n    token.type === NEWLINE\n  );\n}\n\n/**\n * Determines whether the specified token is a function.\n *\n * Returns `true` if the input is a token of type FUNCTION.\n * In all other cases `false` is returned.\n *\n * @param {any} token The token\n * @returns {boolean} True if the specified token is function, False otherwise.\n */\nexport function isFunction (token) {\n  return !!token && token.type === FUNCTION;\n}\n\n/**\n * Returns `true` if the input is a token of type FX_PREFIX (leading `=` in\n * formula). In all other cases `false` is returned.\n *\n * @param {any} token The token\n * @returns {boolean} True if the specified token is effects prefix, False otherwise.\n */\nexport function isFxPrefix (token) {\n  return !!token && token.type === FX_PREFIX;\n}\n\n/**\n * Determines whether the specified token is an operator.\n *\n * Returns `true` if the input is a token of type OPERATOR (`+` or `:`). In all\n * other cases `false` is returned.\n *\n * @param {any} token The token\n * @returns {boolean} True if the specified token is operator, False otherwise.\n */\nexport function isOperator (token) {\n  return !!token && token.type === OPERATOR;\n}\n","/*\n * Excel formula language parser\n *\n * This parser is a Top-Down Operator Precedence (Pratt) parser. It's based on\n * the one that Douglas Crockford describes in Chapter 9 of the O'Reilly book\n * Beutiful Code (http://crockford.com/javascript/tdop/tdop.html).\n *\n * The parser handles most basic things Excel/Sheets do except:\n * `Sheet1:Sheet2!A1` references cross contexts (3D references)\n */\nimport {\n  isReference,\n  isLiteral,\n  isFunction,\n  isWhitespace,\n  isFxPrefix,\n  isOperator,\n  isError\n} from './isType.js';\nimport {\n  UNARY,\n  BINARY,\n  REFERENCE,\n  LITERAL,\n  ERROR_LITERAL,\n  CALL,\n  LAMBDA,\n  ARRAY,\n  IDENTIFIER,\n  NUMBER,\n  BOOLEAN,\n  ERROR,\n  STRING,\n  LET,\n  LET_DECL,\n  REF_NAMED,\n  REF_STRUCT,\n  REF_BEAM\n} from './constants.js';\n\nimport { tokenize } from './lexer.js';\n\nconst END = '(END)';\nconst FUNCTION = '(FUNCTION)';\nconst WHITESPACE = '(WHITESPACE)';\n\nconst refFunctions = [\n  'ANCHORARRAY',\n  'CHOOSE',\n  'DROP',\n  'IF',\n  'IFS',\n  'INDEX',\n  'INDIRECT',\n  'LAMBDA',\n  'LET',\n  'OFFSET',\n  'REDUCE',\n  'SINGLE',\n  'SWITCH',\n  'TAKE',\n  'TRIMRANGE',\n  'XLOOKUP'\n];\n\nconst symbolTable = {};\nlet currentNode;\nlet tokens;\nlet tokenIndex;\nlet permitArrayRanges = false;\nlet permitArrayCalls = false;\nlet looseRefCalls = false;\n\nconst isReferenceFunctionName = fnName => {\n  return looseRefCalls || refFunctions.includes(fnName.toUpperCase());\n};\n\nconst isReferenceToken = (token, allowOperators = false) => {\n  const value = (token && token.value) + '';\n  if (isReference(token)) {\n    return true;\n  }\n  if (allowOperators && isOperator(token) && (value === ':' || value === ',' || !value.trim())) {\n    return true; // join, union, intersection\n  }\n  if (isFunction(token) && isReferenceFunctionName(value)) {\n    return true; // function that yields reference\n  }\n  if (isError(token) && value === '#REF!') {\n    return true;\n  }\n  return false;\n};\n\nconst isReferenceNode = node => {\n  return (!!node) && (\n    (node.type === REFERENCE) ||\n    ((node.type === ERROR_LITERAL || node.type === ERROR) && node.value === '#REF!') ||\n    (node.type === BINARY && (\n      node.operator === ':' ||\n      node.operator === ' ' ||\n      node.operator === ',')\n    ) ||\n    isReference(node) ||\n    (node.type === CALL && isReferenceFunctionName(node.callee.name))\n  );\n};\n\nfunction halt (message, atIndex = null) {\n  const err = new Error(message);\n  err.source = tokens.map(d => d.value).join('');\n  err.sourceOffset = tokens\n    .slice(0, atIndex ?? tokenIndex)\n    .reduce((a, d) => a + d.value.length, 0);\n  throw err;\n}\n\n// A1 A1 | A1 (A1) | A1 ((A1)) | A1 ( (A1) ) | ...\nfunction refIsUpcoming (allowOperators = false) {\n  let i = tokenIndex;\n  let next;\n  do {\n    next = tokens[++i];\n  }\n  while (\n    next && (\n      isWhitespace(next) ||\n      (isOperator(next) && next.value === '(')\n    )\n  );\n  return isReferenceToken(next, allowOperators);\n}\n\nfunction advance (expectNext = null, leftNode = null) {\n  if (expectNext && expectNext !== currentNode.id) {\n    halt(`Expected ${expectNext} but got ${currentNode.id}`);\n  }\n  // look ahead to see if we have ( ( \" \", \"(\" )+ REF )\n  if (isWhitespace(tokens[tokenIndex])) {\n    // potential intersection operation (so don't allow operators as upcoming)\n    const haveRef = isReferenceNode(leftNode);\n    const possibleWSOp = haveRef && refIsUpcoming(false);\n    const nextIsCall = haveRef && tokens[tokenIndex + 1] && tokens[tokenIndex + 1].value === '(';\n    if (!possibleWSOp && !nextIsCall) {\n      // ignore whitespace\n      while (isWhitespace(tokens[tokenIndex])) {\n        tokenIndex++;\n      }\n    }\n  }\n  // EOT\n  if (tokenIndex >= tokens.length) {\n    currentNode = symbolTable[END];\n    return;\n  }\n\n  const token = tokens[tokenIndex];\n  tokenIndex += 1;\n\n  if (token.unterminated) {\n    halt('Encountered an unterminated token');\n  }\n\n  let node;\n  if (isOperator(token)) {\n    node = symbolTable[token.value];\n    if (!node) {\n      halt(`Unknown operator ${token.value}`);\n    }\n  }\n  else if (isWhitespace(token)) {\n    node = symbolTable[WHITESPACE];\n  }\n  else if (isLiteral(token)) {\n    node = symbolTable[LITERAL];\n  }\n  else if (isReference(token)) {\n    node = symbolTable[REFERENCE];\n  }\n  else if (isFunction(token)) {\n    node = symbolTable[FUNCTION];\n  }\n  else {\n    halt(`Unexpected ${token.type} token: ${token.value}`);\n  }\n\n  currentNode = Object.create(node);\n  currentNode.type = token.type;\n  currentNode.value = token.value;\n  if (token.loc) {\n    currentNode.loc = [ ...token.loc ];\n  }\n  return currentNode;\n}\n\nfunction expression (rbp) {\n  let t = currentNode;\n  advance(null, t);\n  let left = t.nud();\n  while (rbp < currentNode.lbp) {\n    t = currentNode;\n    advance(null, t);\n    left = t.led(left);\n  }\n  return left;\n}\n\nconst original_symbol = {\n  // null denotation\n  nud: () => halt('Invalid syntax'), // Undefined\n  // left denotation\n  led: () => halt('Missing operator')\n};\n\n// bp = binding power\nfunction symbol (id, bp = 0) {\n  let s = symbolTable[id];\n  if (s) {\n    if (bp >= s.lbp) {\n      s.lbp = bp;\n    }\n  }\n  else {\n    s = { ...original_symbol };\n    s.id = id;\n    s.value = id;\n    s.lbp = bp;\n    symbolTable[id] = s;\n  }\n  return s;\n}\n\nfunction infix (id, bp, led) {\n  const s = symbol(id, bp);\n  s.led = led || function (left) {\n    this.type = BINARY;\n    this.operator = this.value;\n    delete this.value;\n    const right = expression(bp);\n    this.arguments = [ left, right ];\n    if (this.loc) {\n      this.loc = [ left.loc[0], right.loc[1] ];\n    }\n    return this;\n  };\n  return s;\n}\n\nfunction postfix (id, led) {\n  const s = symbol(id, 0);\n  s.lbp = 70;\n  s.led = led || function (left) {\n    this.type = UNARY;\n    this.operator = this.value;\n    delete this.value;\n    this.arguments = [ left ];\n    if (this.loc) {\n      this.loc[0] = left.loc[0];\n    }\n    return this;\n  };\n  return s;\n}\n\nfunction prefix (id, nud) {\n  const s = symbol(id);\n  s.nud = nud || function () {\n    this.type = UNARY;\n    this.operator = this.value;\n    delete this.value;\n    const subexpr = expression(70);\n    this.arguments = [ subexpr ];\n    if (this.loc) {\n      this.loc[1] = subexpr.loc[1];\n    }\n    return this;\n  };\n  return s;\n}\n\nfunction rangeInfix (id, bp) {\n  return infix(id, bp, function (left) {\n    if (!isReferenceNode(left)) {\n      halt(`Unexpected ${id} operator`);\n    }\n    const right = expression(bp);\n    if (!isReferenceNode(right, true)) {\n      halt(`Unexpected ${currentNode.type} following ${this.id}`);\n    }\n    this.type = BINARY;\n    this.operator = this.value.trim() ? this.value : ' '; // hack around whitespace op\n    delete this.value;\n    this.arguments = [ left, right ];\n    if (this.loc) {\n      this.loc = [ left.loc[0], right.loc[1] ];\n    }\n    return this;\n  });\n}\n\nsymbol(END);\n\n// reference operators\nrangeInfix(':', 80); // range join/extend =B7:OFFSET(A1,10,10)\nconst comma = rangeInfix(',', 80); // union =B7:D7,C6:C8\nrangeInfix(WHITESPACE, 80); // intersect: =B7:D7 C6:C8\n\n// Excel's grammar is ambiguous. This turns the , operator's left binding\n// power on/off which allows us to treat , as a symbol where we need.\nconst unionRefs = enable => {\n  const currState = comma.lbp > 0;\n  if (enable != null) { comma.lbp = enable ? 80 : 0; }\n  return currState;\n};\n\n// arithmetic and string operations\npostfix('%'); // percent\npostfix('#', function (left) { // spilled range (_xlfn.ANCHORARRAY)\n  if (!isReferenceNode(left)) {\n    halt('# expects a reference');\n  }\n  this.type = UNARY;\n  this.operator = this.value;\n  delete this.value;\n  this.arguments = [ left ];\n  return this;\n}); // range\nprefix('+'); // unary plus\nprefix('-'); // unary minus\nprefix('@'); // implicit intersection (_xlfn.SINGLE)\ninfix('^', 50); // power\ninfix('*', 40); // multiply\ninfix('/', 40); // divide\ninfix('+', 30); // add\ninfix('-', 30); // subtract\ninfix('&', 20); // text concat\n\n// comparison\ninfix('=', 10);\ninfix('<', 10);\ninfix('>', 10);\ninfix('<=', 10);\ninfix('>=', 10);\ninfix('<>', 10);\nsymbol(LITERAL).nud = function () {\n  const { type, value } = this;\n  this.type = LITERAL;\n  this.raw = value;\n  if (type === NUMBER) {\n    this.value = +value;\n  }\n  else if (type === BOOLEAN) {\n    this.value = value.toUpperCase() === 'TRUE';\n  }\n  else if (type === ERROR) {\n    this.type = ERROR_LITERAL;\n    this.value = value.toUpperCase();\n  }\n  else if (type === STRING) {\n    // FIXME: throw an error if the string is unterminated\n    this.value = value.slice(1, -1).replace(/\"\"/g, '\"');\n  }\n  else {\n    throw new Error('Unsupported literal type: ' + type);\n  }\n  return this;\n};\nsymbol(REFERENCE).nud = function () {\n  if (this.type === REF_NAMED) {\n    this.kind = 'name';\n  }\n  else if (this.type === REF_STRUCT) {\n    this.kind = 'table'; // structured ?\n  }\n  else if (this.type === REF_BEAM) {\n    this.kind = 'beam';\n  }\n  else {\n    this.kind = 'range';\n  }\n  this.type = REFERENCE;\n  return this;\n};\n\n// parens\nsymbol(')');\nprefix('(', function () {\n  const prevState = unionRefs(true);\n  const e = expression(0);\n  advance(')', e);\n  unionRefs(prevState);\n  return e;\n});\n\n// function call\nsymbol(FUNCTION).nud = function () {\n  return this;\n};\ninfix('(', 90, function (left) {\n  let callee = {\n    type: IDENTIFIER,\n    name: left.value\n  };\n  if (left.id !== FUNCTION) {\n    if (\n      left.type === LAMBDA ||\n      // Excel only allows calls to \"names\" and ref functions. Since we don't\n      // differentiate between the two (this requires a table of function names)\n      // we're overly permissive here:\n      left.type === CALL ||\n      left.type === LET ||\n      left.type === REFERENCE ||\n      (left.type === UNARY && left.value === '#') || // Because it's really SINGLE(...)()\n      (left.type === ERROR_LITERAL && left.value === '#REF!')\n    ) {\n      // in the case of REFERENCE, do we want to set the node to Identifier?\n      callee = left;\n    }\n    else {\n      halt('Unexpected call', tokenIndex - 1);\n    }\n  }\n  const lcFn = left.value.toLowerCase();\n  if (lcFn === 'lambda') {\n    return parseLambda.call(this, left);\n  }\n  if (lcFn === 'let') {\n    return parseLet.call(this, left);\n  }\n  const args = [];\n  let lastWasComma = false;\n  if (currentNode.id !== ')') {\n    const prevState = unionRefs(false);\n    while (currentNode.id !== ')') {\n      if (isWhitespace(currentNode)) {\n        advance();\n      }\n      if (currentNode.id === ',') {\n        args.push(null);\n        lastWasComma = true;\n        advance();\n      }\n      else {\n        const arg = expression(0);\n        args.push(arg);\n        lastWasComma = false;\n        if (currentNode.id === ',') {\n          advance(',');\n          lastWasComma = true;\n        }\n      }\n    }\n    unionRefs(prevState);\n  }\n  if (lastWasComma) {\n    args.push(null);\n  }\n  const closeParen = currentNode;\n  delete this.value;\n  this.type = CALL;\n  this.callee = callee;\n  if (left.loc) {\n    this.callee.loc = [ ...left.loc ];\n  }\n  this.arguments = args;\n  if (left.loc) {\n    this.loc = [ left.loc[0], closeParen.loc[1] ];\n  }\n  advance(')', this);\n  return this;\n});\n\nfunction parseLambda (left) {\n  const args = [];\n  const argNames = {};\n  let body;\n  let done = false;\n  const prevState = unionRefs(false);\n  if (currentNode.id !== ')') {\n    while (!done) {\n      if (isWhitespace(currentNode)) {\n        advance();\n      }\n      const argTokenIndex = tokenIndex;\n      const arg = expression(0);\n      if (currentNode.id === ',') {\n        // all but last args must be names\n        if (arg.type === REFERENCE && arg.kind === 'name') {\n          // names may not be duplicates\n          const currName = arg.value.toLowerCase();\n          if (currName in argNames) {\n            halt('Duplicate name: ' + arg.value);\n          }\n          argNames[currName] = 1;\n          const a = { type: IDENTIFIER, name: arg.value };\n          if (arg.loc) { a.loc = arg.loc; }\n          args.push(a);\n        }\n        else {\n          tokenIndex = argTokenIndex;\n          halt('LAMBDA argument is not a name');\n        }\n        advance(',');\n      }\n      else {\n        body = arg;\n        done = true;\n      }\n    }\n  }\n  unionRefs(prevState);\n  delete this.value;\n  this.type = LAMBDA;\n  this.params = args;\n  this.body = body || null;\n  if (left.loc) {\n    this.loc = [ left.loc[0], currentNode.loc[1] ];\n  }\n  advance(')', this);\n  return this;\n}\n\nfunction parseLet (left) {\n  const args = [];\n  const vals = [];\n  const argNames = {};\n  let body;\n  let argCounter = 0;\n  const addArgument = (arg, lastArg) => {\n    if (body) {\n      halt('Unexpected argument following calculation');\n    }\n    if (lastArg && argCounter >= 2) {\n      body = arg;\n    }\n    else {\n      const wantName = !(argCounter % 2);\n      if (wantName) {\n        if (arg && (arg.type === REFERENCE && arg.kind === 'name')) {\n          // names may not be duplicates\n          const currName = arg.value.toLowerCase();\n          if (currName in argNames) {\n            halt('Duplicate name: ' + arg.value);\n          }\n          argNames[currName] = 1;\n          args.push({ type: IDENTIFIER, name: arg.value, loc: arg.loc });\n        }\n        else if (argCounter >= 2) {\n          body = arg;\n        }\n        else {\n          halt('Argument is not a name');\n        }\n      }\n      else {\n        vals.push(arg);\n      }\n    }\n    argCounter++;\n  };\n  const prevState = unionRefs(false);\n  let lastWasComma = false;\n  if (currentNode.id !== ')') {\n    while (currentNode.id !== ')') {\n      if (isWhitespace(currentNode)) {\n        advance();\n      }\n      if (currentNode.id === ',') {\n        addArgument(null);\n        lastWasComma = true;\n        advance();\n      }\n      else {\n        const arg = expression(0);\n        addArgument(arg, currentNode.id !== ',');\n        lastWasComma = false;\n        if (currentNode.id === ',') {\n          advance(',');\n          lastWasComma = true;\n        }\n      }\n    }\n    unionRefs(prevState);\n  }\n  if (lastWasComma) {\n    addArgument(null, true);\n  }\n  if (body === undefined) {\n    halt('Unexpected end of arguments');\n  }\n  unionRefs(prevState);\n  delete this.value;\n  this.type = LET;\n  this.declarations = [];\n  if (!args.length) {\n    halt('Unexpected end of arguments');\n  }\n  for (let i = 0; i < args.length; i++) {\n    const s = {\n      type: LET_DECL,\n      id: args[i],\n      init: vals[i],\n      loc: args[i].loc && [ args[i].loc[0], vals[i].loc[1] ]\n    };\n    this.declarations.push(s);\n  }\n  this.body = body;\n  if (left.loc) {\n    this.loc = [ left.loc[0], currentNode.loc[1] ];\n  }\n  advance(')', this);\n  return this;\n}\n\n// array literal\nsymbol('}');\nsymbol(';');\nprefix('{', function () {\n  if (currentNode.id === '}') { // arrays must not be empty\n    halt('Unexpected empty array');\n  }\n  let row = [];\n  let done = false;\n  const rows = [ row ];\n  const prevState = unionRefs(false);\n  while (!done) {\n    if (isWhitespace(currentNode)) {\n      advance();\n    }\n    // arrays allow only literals, ranges (in GSheets) and ,;: operators.\n    // FIXME: if { negativeNumbers: false } we must consume minuses as well.\n    // Excel allows ={-1} but not ={(-1)} and ={1%}\n    if (isLiteral(currentNode)) {\n      row.push(symbolTable[LITERAL].nud.call(currentNode));\n      advance();\n    }\n    else if (permitArrayRanges && isReferenceNode(currentNode)) {\n      row.push(symbolTable[REFERENCE].nud.call(currentNode));\n      advance();\n    }\n    else if (permitArrayCalls && isFunction(currentNode)) {\n      const arg = expression(0);\n      row.push(arg);\n    }\n    else {\n      halt(`Unexpected ${currentNode.type} in array: ${currentNode.value}`);\n    }\n    if (currentNode.id === ',') {\n      // next item\n      advance(',');\n    }\n    else if (currentNode.id === ';') {\n      // next row\n      advance(';');\n      row = [];\n      rows.push(row);\n    }\n    else {\n      done = true;\n    }\n  }\n  const closingBrace = currentNode;\n  advance('}');\n  unionRefs(prevState);\n  this.type = ARRAY;\n  this.elements = rows;\n  if (this.loc) {\n    this.loc[1] = closingBrace.loc[1];\n  }\n  delete this.value;\n  return this;\n});\n\n/**\n * Parses a string formula or list of tokens into an AST.\n *\n * The parser requires `mergeRefs` to have been `true` in tokenlist options,\n * because it does not recognize reference context tokens.\n *\n * The AST Abstract Syntax Tree's format is documented in\n * [AST_format.md](./AST_format.md)\n *\n * @see nodeTypes\n * @param {(string | Token[])} formula An Excel formula string (an Excel expression) or an array of tokens.\n * @param {object} [options={}]  Options\n * @param {boolean} [options.allowNamed=true]  Enable parsing names as well as ranges.\n * @param {boolean} [options.allowTernary=false]  Enables the recognition of ternary ranges in the style of `A1:A` or `A1:1`. These are supported by Google Sheets but not Excel. See: References.md.\n * @param {boolean} [options.negativeNumbers=true]  Merges unary minuses with their immediately following number tokens (`-`,`1`) => `-1` (alternatively these will be unary operations in the tree).\n * @param {boolean} [options.permitArrayRanges=false]  Ranges are allowed as elements of arrays. This is a feature in Google Sheets while Excel does not allow it.\n * @param {boolean} [options.permitArrayCalls=false]  Function calls are allowed as elements of arrays. This is a feature in Google Sheets while Excel does not allow it.\n * @param {boolean} [options.looseRefCalls=false]  Permits any function call where otherwise only functions that return references would be permitted.\n * @param {boolean} [options.r1c1=false]  Ranges are expected to be in the R1C1 style format rather than the more popular A1 style.\n * @param {boolean} [options.withLocation=false]  Nodes will include source position offsets to the tokens: `{ loc: [ start, end ] }`\n * @param {boolean} [options.xlsx=false]  Switches to the `[1]Sheet1!A1` or `[1]!name` prefix syntax form for external workbooks. See: [Prefixes.md](./Prefixes.md)\n * @returns {AstExpression} An AST of nodes\n */\nexport function parse (formula, options) {\n  if (typeof formula === 'string') {\n    tokens = tokenize(formula, {\n      withLocation: false,\n      ...options,\n      mergeRefs: true\n    });\n  }\n  else if (Array.isArray(formula)) {\n    tokens = formula;\n  }\n  else {\n    throw new Error('Parse requires a string or array of tokens.');\n  }\n  // allow ranges in array \"literals\"?\n  permitArrayRanges = options?.permitArrayRanges;\n  // allow calls in arrays \"literals\"?\n  permitArrayCalls = options?.permitArrayCalls;\n  // allow any function call in range operations?\n  looseRefCalls = options?.looseRefCalls;\n  // set index to start\n  tokenIndex = 0;\n  // discard redundant whitespace and = prefix\n  while (isWhitespace(tokens[tokenIndex]) || isFxPrefix(tokens[tokenIndex])) {\n    tokenIndex++;\n  }\n  advance();\n  unionRefs(true);\n  const root = expression(0);\n  advance(END);\n  return root;\n}\n","import {\n  FX_PREFIX,\n  CONTEXT,\n  CONTEXT_QUOTE,\n  REF_RANGE,\n  REF_TERNARY,\n  REF_NAMED,\n  REF_BEAM,\n  REF_STRUCT,\n  OPERATOR\n} from './constants.js';\nimport { lexersRefs } from './lexers/sets.js';\nimport { getTokens } from './lexer.js';\n\n// Liberally split a context string up into parts.\n// Permits any combination of braced and unbraced items.\nexport function splitPrefix (str, stringsOnly = false) {\n  let inBrace = false;\n  let currStr = '';\n  const parts = [];\n  const flush = () => {\n    if (currStr) {\n      parts.push(\n        stringsOnly\n          ? currStr\n          : { value: currStr, braced: inBrace }\n      );\n    }\n    currStr = '';\n  };\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n    if (char === '[') {\n      flush();\n      inBrace = true;\n    }\n    else if (char === ']') {\n      flush();\n      inBrace = false;\n    }\n    else {\n      currStr += char;\n    }\n  }\n  flush();\n  return parts;\n}\n\nfunction splitContext (contextString, data, xlsx) {\n  const ctx = splitPrefix(contextString, !xlsx);\n  if (xlsx) {\n    if (ctx.length > 1) {\n      data.workbookName = ctx[ctx.length - 2].value;\n      data.sheetName = ctx[ctx.length - 1].value;\n    }\n    else if (ctx.length === 1) {\n      const item = ctx[0];\n      if (item.braced) {\n        data.workbookName = item.value;\n      }\n      else {\n        data.sheetName = item.value;\n      }\n    }\n  }\n  else {\n    data.context = ctx;\n  }\n}\n\nconst unquote = d => d.slice(1, -1).replace(/''/g, \"'\");\n\nconst pRangeOp = (t, data) => {\n  const value = t?.value;\n  if (value === ':' || value === '.:' || value === ':.' || value === '.:.') {\n    data.operator = value;\n    return 1;\n  }\n};\nconst pRange = (t, data) => {\n  if (t?.type === REF_RANGE) {\n    data.r0 = t.value;\n    return 1;\n  }\n};\nconst pPartial = (t, data) => {\n  if (t?.type === REF_TERNARY) {\n    data.r0 = t.value;\n    return 1;\n  }\n};\nconst pRange2 = (t, data) => {\n  if (t?.type === REF_RANGE) {\n    data.r1 = t.value;\n    return 1;\n  }\n};\nconst pBang = t => {\n  if (t?.type === OPERATOR && t.value === '!') {\n    return 1;\n  }\n};\nconst pBeam = (t, data) => {\n  if (t?.type === REF_BEAM) {\n    data.r0 = t.value;\n    return 1;\n  }\n};\nconst pStrucured = (t, data) => {\n  if (t.type === REF_STRUCT) {\n    data.struct = t.value;\n    return 1;\n  }\n};\nconst pContext = (t, data, xlsx) => {\n  const type = t?.type;\n  if (type === CONTEXT) {\n    splitContext(t.value, data, xlsx);\n    return 1;\n  }\n  if (type === CONTEXT_QUOTE) {\n    splitContext(unquote(t.value), data, xlsx);\n    return 1;\n  }\n};\nconst pNamed = (t, data) => {\n  if (t?.type === REF_NAMED) {\n    data.name = t.value;\n    return 1;\n  }\n};\n\nconst validRuns = [\n  [ pPartial ],\n  [ pRange, pRangeOp, pRange2 ],\n  [ pRange ],\n  [ pBeam ],\n  [ pContext, pBang, pPartial ],\n  [ pContext, pBang, pRange, pRangeOp, pRange2 ],\n  [ pContext, pBang, pRange ],\n  [ pContext, pBang, pBeam ]\n];\n\nconst validRunsNamed = validRuns.concat([\n  [ pNamed ],\n  [ pContext, pBang, pNamed ],\n  [ pStrucured ],\n  [ pNamed, pStrucured ],\n  [ pContext, pBang, pNamed, pStrucured ]\n]);\n\nexport function parseRef (ref, opts) {\n  const options = {\n    withLocation: opts.withLocation ?? false,\n    mergeRefs: opts.mergeRefs ?? false,\n    allowTernary: opts.allowTernary ?? false,\n    allowNamed: opts.allowNamed ?? true,\n    r1c1: opts.r1c1 ?? false,\n    xlsx: opts.xlsx ?? false\n  };\n  const tokens = getTokens(ref, lexersRefs, options);\n  const xlsx = options.xlsx;\n\n  // discard the \"=\"-prefix if it is there\n  if (tokens.length && tokens[0].type === FX_PREFIX) {\n    tokens.shift();\n  }\n  const runs = options.allowNamed ? validRunsNamed : validRuns;\n  for (const run of runs) {\n    // const len = run.length;\n    if (run.length === tokens.length) {\n      const data = xlsx\n        ? {\n          workbookName: '',\n          sheetName: '',\n          r0: '',\n          r1: '',\n          name: '',\n          operator: ''\n        }\n        : {\n          context: [],\n          r0: '',\n          r1: '',\n          name: '',\n          operator: ''\n        };\n      const valid = run.every((parse, i) => parse(tokens[i], data, xlsx));\n      if (valid) {\n        return data;\n      }\n    }\n  }\n  return null;\n}\n","const charFrom = String.fromCharCode;\n\n/**\n * Convert a 0 based offset number to a column string\n * representation (`2` = `\"C\"`).\n *\n * The method expects a number between 0 and 16383. Other input will\n * return garbage.\n *\n * @param {number} columnIndex Zero based column index number\n * @returns {string} The column string identifier\n */\nexport function toCol (columnIndex) {\n  return (\n    (columnIndex >= 702\n      ? charFrom(((((columnIndex - 702) / 676) - 0) % 26) + 65)\n      : '') +\n    (columnIndex >= 26\n      ? charFrom(((((columnIndex / 26) - 1) % 26) + 65))\n      : '') +\n    charFrom((columnIndex % 26) + 65)\n  );\n}\n","const reBannedChars = /[^0-9A-Za-z._¡¤§¨ª\\u00ad¯-\\uffff]/;\n\nexport function stringifyPrefix (ref) {\n  let pre = '';\n  let quote = 0;\n  let nth = 0;\n  const context = ref.context || [];\n  for (let i = context.length; i > -1; i--) {\n    const scope = context[i];\n    if (scope) {\n      const part = (nth % 2) ? '[' + scope + ']' : scope;\n      pre = part + pre;\n      quote += +reBannedChars.test(scope);\n      nth++;\n    }\n  }\n  if (quote) {\n    pre = \"'\" + pre.replace(/'/g, \"''\") + \"'\";\n  }\n  return pre ? pre + '!' : pre;\n}\n\nexport function stringifyPrefixAlt (ref) {\n  let pre = '';\n  let quote = 0;\n  const { workbookName, sheetName } = ref;\n  if (workbookName) {\n    pre += '[' + workbookName + ']';\n    quote += +reBannedChars.test(workbookName);\n  }\n  if (sheetName) {\n    pre += sheetName;\n    quote += +reBannedChars.test(sheetName);\n  }\n  if (quote) {\n    pre = \"'\" + pre.replace(/'/g, \"''\") + \"'\";\n  }\n  return pre ? pre + '!' : pre;\n}\n","import { MAX_COLS, MAX_ROWS } from './constants.js';\n\nexport function fromRow (rowStr) {\n  return +rowStr - 1;\n}\n\nconst CHAR_DOLLAR = 36;\nconst CHAR_PERIOD = 46;\nconst CHAR_COLON = 58;\nconst CHAR_A_LC = 97;\nconst CHAR_A_UC = 65;\nconst CHAR_Z_LC = 122;\nconst CHAR_Z_UC = 90;\nconst CHAR_0 = 48;\nconst CHAR_1 = 49;\nconst CHAR_9 = 57;\n\n/**\n * @ignore\n * @param {string} str\n * @param {number} pos\n * @returns {[ number, string ]}\n */\nfunction advRangeOp (str, pos) {\n  const c0 = str.charCodeAt(pos);\n  if (c0 === CHAR_PERIOD) {\n    const c1 = str.charCodeAt(pos + 1);\n    if (c1 === CHAR_COLON) {\n      return str.charCodeAt(pos + 2) === CHAR_PERIOD\n        ? [ 3, 'both' ]\n        : [ 2, 'head' ];\n    }\n  }\n  else if (c0 === CHAR_COLON) {\n    const c1 = str.charCodeAt(pos + 1);\n    return c1 === CHAR_PERIOD\n      ? [ 2, 'tail' ]\n      : [ 1, '' ];\n  }\n  return [ 0, '' ];\n}\n\n/**\n * @ignore\n * @param {string} str\n * @param {number} pos\n * @returns {[ number, number, boolean ]}\n */\nfunction advA1Col (str, pos) {\n  // [A-Z]{1,3}\n  const start = pos;\n  const lock = str.charCodeAt(pos) === CHAR_DOLLAR;\n  if (lock) { pos++; }\n  const stop = pos + 3;\n  let col = 0;\n  do {\n    const c = str.charCodeAt(pos);\n    if (c >= CHAR_A_UC && c <= CHAR_Z_UC) {\n      col = (26 * col) + c - (CHAR_A_UC - 1);\n      pos++;\n    }\n    else if (c >= CHAR_A_LC && c <= CHAR_Z_LC) {\n      col = (26 * col) + c - (CHAR_A_LC - 1);\n      pos++;\n    }\n    else {\n      break;\n    }\n  }\n  while (pos < stop && pos < str.length);\n  return (col && col <= MAX_COLS + 1)\n    ? [ pos - start, col - 1, lock ]\n    : [ 0, 0, false ];\n}\n\n/**\n * @ignore\n * @param {string} str\n * @param {number} pos\n * @returns {[ number, number, boolean ]}\n */\nfunction advA1Row (str, pos) {\n  // [1-9][0-9]{0,6}\n  const start = pos;\n  const lock = str.charCodeAt(pos) === CHAR_DOLLAR;\n  if (lock) { pos++; }\n  const stop = pos + 7;\n  let row = 0;\n  let c = str.charCodeAt(pos);\n  if (c >= CHAR_1 && c <= CHAR_9) {\n    row = (row * 10) + c - CHAR_0;\n    pos++;\n    do {\n      c = str.charCodeAt(pos);\n      if (c >= CHAR_0 && c <= CHAR_9) {\n        row = (row * 10) + c - CHAR_0;\n        pos++;\n      }\n      else {\n        break;\n      }\n    }\n    while (pos < stop && pos < str.length);\n  }\n  return (row && row <= MAX_ROWS + 1)\n    ? [ pos - start, row - 1, lock ]\n    : [ 0, 0, false ];\n}\n\nfunction makeRange (top, $top, left, $left, bottom, $bottom, right, $right, trim) {\n  // flip left/right and top/bottom as needed\n  // for partial ranges we perfer the coord on the left-side of the:\n  if (right != null && (left == null || (left != null && right < left))) {\n    [ left, right, $left, $right ] = [ right, left, $right, $left ];\n  }\n  if (bottom != null && (top == null || (top != null && bottom < top))) {\n    [ top, bottom, $top, $bottom ] = [ bottom, top, $bottom, $top ];\n  }\n  const range = { top, left, bottom, right, $top, $left, $bottom, $right };\n  if (trim) {\n    range.trim = trim;\n  }\n  return range;\n}\n\nexport function fromA1 (str, allowTernary = true) {\n  let p = 0;\n  const [ leftChars, left, $left ] = advA1Col(str, p);\n  let right = 0;\n  let $right = false;\n  let bottom = 0;\n  let $bottom = false;\n  let rightChars;\n  let bottomChars;\n  if (leftChars) {\n    // TLBR: could be A1:A1\n    // TL R: could be A1:A (if allowTernary)\n    // TLB : could be A1:1 (if allowTernary)\n    //  LBR: could be A:A1 (if allowTernary)\n    //  L R: could be A:A\n    p += leftChars;\n    const [ topChars, top, $top ] = advA1Row(str, p);\n    p += topChars;\n    const [ op, trim ] = advRangeOp(str, p);\n    if (op) {\n      p += op;\n      [ rightChars, right, $right ] = advA1Col(str, p);\n      p += rightChars;\n      [ bottomChars, bottom, $bottom ] = advA1Row(str, p);\n      p += bottomChars;\n      if (topChars && bottomChars && rightChars) {\n        if (p === str.length) {\n          return makeRange(top, $top, left, $left, bottom, $bottom, right, $right, trim);\n        }\n      }\n      else if (!topChars && !bottomChars) {\n        if (p === str.length) {\n          return makeRange(null, false, left, $left, null, false, right, $right, trim);\n        }\n      }\n      else if (allowTernary && (bottomChars || rightChars) && p === str.length) {\n        if (!topChars) {\n          return makeRange(null, false, left, $left, bottom, $bottom, right, $right, trim);\n        }\n        else if (!bottomChars) {\n          return makeRange(top, $top, left, $left, null, false, right, $right, trim);\n        }\n        else {\n          return makeRange(top, $top, left, $left, bottom, $bottom, null, false, trim);\n        }\n      }\n    }\n    // LT  : this is A1\n    if (topChars && p === str.length) {\n      return makeRange(top, $top, left, $left, top, $top, left, $left, trim);\n    }\n  }\n  else {\n    // T B : could be 1:1\n    // T BR: could be 1:A1 (if allowTernary)\n    const [ topChars, top, $top ] = advA1Row(str, p);\n    if (topChars) {\n      p += topChars;\n      const [ op, trim ] = advRangeOp(str, p);\n      if (op) {\n        p += op;\n        [ rightChars, right, $right ] = advA1Col(str, p);\n        p += rightChars;\n        [ bottomChars, bottom, $bottom ] = advA1Row(str, p);\n        p += bottomChars;\n        if (rightChars && bottomChars && allowTernary) {\n          if (p === str.length) {\n            return makeRange(top, $top, null, false, bottom, $bottom, right, $right, trim);\n          }\n        }\n        else if (!rightChars && bottomChars) {\n          if (p === str.length) {\n            return makeRange(top, $top, null, false, bottom, $bottom, null, false, trim);\n          }\n        }\n      }\n    }\n  }\n  return null;\n}\n","import { MAX_ROWS, MAX_COLS } from './constants.js';\nimport { parseRef } from './parseRef.js';\nimport { toCol } from './toCol.js';\nimport { stringifyPrefix, stringifyPrefixAlt } from './stringifyPrefix.js';\nimport { fromA1 } from './fromA1.js';\n\nconst clamp = (min, val, max) => Math.min(Math.max(val, min), max);\nconst toColStr = (c, a) => (a ? '$' : '') + toCol(c);\nconst toRowStr = (r, a) => (a ? '$' : '') + toRow(r);\n\nexport function toRelative (range) {\n  return Object.assign({}, range, { $left: false, $right: false, $top: false, $bottom: false });\n}\n\nexport function toAbsolute (range) {\n  return Object.assign({}, range, { $left: true, $right: true, $top: true, $bottom: true });\n}\n\nexport function toRow (top) {\n  return String(top + 1);\n}\n\n/**\n * @ignore\n * @param {'head' | 'tail' | 'both' | null | undefined} trim Does the range have trimming?\n * @returns {string} The appropriate range join operator\n */\nexport function rangeOperator (trim) {\n  if (trim === 'both') {\n    return '.:.';\n  }\n  else if (trim === 'head') {\n    return '.:';\n  }\n  else if (trim === 'tail') {\n    return ':.';\n  }\n  return ':';\n}\n\n/**\n * Stringify a range object into A1 syntax.\n *\n * @private\n * @ignore\n * @see parseA1Ref\n * @param {RangeA1} range  A range object\n * @returns {string}  An A1-style string represenation of a range\n */\nexport function toA1 (range) {\n  let { top, left, bottom, right, trim } = range;\n  const { $left, $right, $top, $bottom } = range;\n  const noLeft = left == null;\n  const noRight = right == null;\n  const noTop = top == null;\n  const noBottom = bottom == null;\n  // allow skipping right and bottom to define a cell\n  top = clamp(0, top | 0, MAX_ROWS);\n  left = clamp(0, left | 0, MAX_COLS);\n  if (!noLeft && !noTop && noRight && noBottom) {\n    bottom = top;\n    right = left;\n  }\n  else {\n    bottom = clamp(0, bottom | 0, MAX_ROWS);\n    right = clamp(0, right | 0, MAX_COLS);\n  }\n  const op = rangeOperator(trim);\n  // A:A\n  const allRows = top === 0 && bottom >= MAX_ROWS;\n  const haveAbsCol = ($left && !noLeft) || ($right && !noRight);\n  if ((allRows && !noLeft && !noRight && (!haveAbsCol || left === right)) || (noTop && noBottom)) {\n    return toColStr(left, $left) + op + toColStr(right, $right);\n  }\n  // 1:1\n  const allCols = left === 0 && right >= MAX_COLS;\n  const haveAbsRow = ($top && !noTop) || ($bottom && !noBottom);\n  if ((allCols && !noTop && !noBottom && (!haveAbsRow || top === bottom)) || (noLeft && noRight)) {\n    return toRowStr(top, $top) + op + toRowStr(bottom, $bottom);\n  }\n  // A1:1\n  if (!noLeft && !noTop && !noRight && noBottom) {\n    return toColStr(left, $left) + toRowStr(top, $top) + op + toColStr(right, $right);\n  }\n  // A:A1 => A1:1\n  if (!noLeft && noTop && !noRight && !noBottom) {\n    return toColStr(left, $left) + toRowStr(bottom, $bottom) + op + toColStr(right, $right);\n  }\n  // A1:A\n  if (!noLeft && !noTop && noRight && !noBottom) {\n    return toColStr(left, $left) + toRowStr(top, $top) + op + toRowStr(bottom, $bottom);\n  }\n  // A:A1 => A1:A\n  if (noLeft && !noTop && !noRight && !noBottom) {\n    return toColStr(right, $right) + toRowStr(top, $top) + op + toRowStr(bottom, $bottom);\n  }\n  // A1:A1\n  if (right !== left || bottom !== top || $right !== $left || $bottom !== $top) {\n    return toColStr(left, $left) + toRowStr(top, $top) + op +\n           toColStr(right, $right) + toRowStr(bottom, $bottom);\n  }\n  // A1\n  return toColStr(left, $left) + toRowStr(top, $top);\n}\n\n/**\n * Parse a string reference into an object representing it.\n *\n * ```js\n * parseA1Ref('Sheet1!A$1:$B2');\n * // => {\n * //   context: [ 'Sheet1' ],\n * //   range: {\n * //     top: 0,\n * //     left: 0,\n * //     bottom: 1,\n * //     right: 1\n * //     $top: true,\n * //     $left: false,\n * //     $bottom: false,\n * //     $right: true\n * //   }\n * // }\n * ```\n *\n * For A:A or A1:A style ranges, `null` will be used for any dimensions that the\n * syntax does not specify:\n *\n * @param {string} refString  An A1-style reference string\n * @param {object} [options={}]  Options\n * @param {boolean} [options.allowNamed=true]  Enable parsing names as well as ranges.\n * @param {boolean} [options.allowTernary=false]  Enables the recognition of ternary ranges in the style of `A1:A` or `A1:1`. These are supported by Google Sheets but not Excel. See: References.md.\n * @param {boolean} [options.xlsx=false]  Switches to the `[1]Sheet1!A1` or `[1]!name` prefix syntax form for external workbooks. See: [Prefixes.md](./Prefixes.md)\n * @returns {(ReferenceA1|null)} An object representing a valid reference or null if it is invalid.\n */\nexport function parseA1Ref (refString, { allowNamed = true, allowTernary = false, xlsx = false } = {}) {\n  const d = parseRef(refString, { allowNamed, allowTernary, xlsx, r1c1: false });\n  if (d && (d.r0 || d.name)) {\n    let range = null;\n    if (d.r0) {\n      range = fromA1(d.r1 ? d.r0 + d.operator + d.r1 : d.r0);\n    }\n    if (range) {\n      return xlsx\n        ? { workbookName: d.workbookName, sheetName: d.sheetName, range }\n        : { context: d.context, range };\n    }\n    if (d.name) {\n      return xlsx\n        ? { workbookName: d.workbookName, sheetName: d.sheetName, name: d.name }\n        : { context: d.context, name: d.name };\n    }\n    return null;\n  }\n  return null;\n}\n\n/**\n * Get an A1-style string representation of a reference object.\n *\n * ```js\n * stringifyA1Ref({\n *   context: [ 'Sheet1' ],\n *   range: {\n *     top: 0,\n *     left: 0,\n *     bottom: 1,\n *     right: 1,\n *     $top: true,\n *     $left: false,\n *     $bottom: false,\n *     $right: true\n *   }\n * });\n * // => 'Sheet1!A$1:$B2'\n * ```\n *\n * @param {ReferenceA1} refObject A reference object\n * @param {object} [options={}]  Options\n * @param {boolean} [options.xlsx=false]  Switches to the `[1]Sheet1!A1` or `[1]!name` prefix syntax form for external workbooks. See: [Prefixes.md](./Prefixes.md)\n * @returns {string} The reference in A1-style string format\n */\nexport function stringifyA1Ref (refObject, { xlsx = false } = {}) {\n  const prefix = xlsx\n    ? stringifyPrefixAlt(refObject)\n    : stringifyPrefix(refObject);\n  return prefix + (\n    refObject.name ? refObject.name : toA1(refObject.range)\n  );\n}\n\n/**\n * Fill the any missing bounds in range objects. Top will be set to 0, bottom to\n * 1048575, left to 0, and right to 16383, if they are `null` or `undefined`.\n *\n * ```js\n * addA1RangeBounds({\n *   context: [ 'Sheet1' ],\n *   range: {\n *     top: 0,\n *     left: 0,\n *     bottom: 1,\n *     $top: true,\n *     $left: false,\n *     $bottom: false,\n *   }\n * });\n * // => {\n * //   context: [ 'Sheet1' ],\n * //   range: {\n * //     top: 0,\n * //     left: 0,\n * //     bottom: 1,\n * //     right: 16383,\n * //     $top: true,\n * //     $left: false,\n * //     $bottom: false,\n * //     $right: false\n * //   }\n * // }\n * ```\n *\n * @param {RangeA1} range The range part of a reference object.\n * @returns {RangeA1} same range with missing bounds filled in.\n */\nexport function addA1RangeBounds (range) {\n  if (range.top == null) {\n    range.top = 0;\n    range.$top = false;\n  }\n  if (range.bottom == null) {\n    range.bottom = MAX_ROWS;\n    range.$bottom = false;\n  }\n  if (range.left == null) {\n    range.left = 0;\n    range.$left = false;\n  }\n  if (range.right == null) {\n    range.right = MAX_COLS;\n    range.$right = false;\n  }\n  return range;\n}\n","import { parseRef } from './parseRef.js';\nimport { parseSRange } from './parseSRange.js';\n\n/**\n * Parse a structured reference string into an object representing it.\n *\n * ```js\n * parseStructRef('workbook.xlsx!tableName[[#Data],[Column1]:[Column2]]');\n * // => {\n * //   context: [ 'workbook.xlsx' ],\n * //   sections: [ 'data' ],\n * //   columns: [ 'my column', '@foo' ],\n * //   table: 'tableName',\n * // }\n * ```\n *\n * For A:A or A1:A style ranges, `null` will be used for any dimensions that the\n * syntax does not specify:\n *\n * @tutorial References.md\n * @param {string} ref  A structured reference string\n * @param {object} [options={}]  Options\n * @param {boolean} [options.xlsx=false]  Switches to the `[1]Sheet1!A1` or `[1]!name` prefix syntax form for external workbooks. See: [Prefixes.md](./Prefixes.md)\n * @returns {(ReferenceStruct|null)} An object representing a valid reference or null if it is invalid.\n */\nexport function parseStructRef (ref, options = { xlsx: false }) {\n  const r = parseRef(ref, options);\n  if (r && r.struct) {\n    const structData = parseSRange(r.struct);\n    if (structData && structData.length === r.struct.length) {\n      return options.xlsx\n        ? {\n          workbookName: r.workbookName,\n          sheetName: r.sheetName,\n          table: r.name,\n          columns: structData.columns,\n          sections: structData.sections\n        }\n        : {\n          context: r.context,\n          table: r.name,\n          columns: structData.columns,\n          sections: structData.sections\n        };\n    }\n  }\n  return null;\n}\n","import { REF_RANGE, REF_BEAM, REF_TERNARY, UNKNOWN, REF_STRUCT } from './constants.js';\nimport { parseA1Ref } from './a1.js';\nimport { parseStructRef } from './parseStructRef.js';\n\nfunction getIDer () {\n  let i = 1;\n  return () => 'fxg' + (i++);\n}\n\nfunction sameValue (a, b) {\n  if (a == null && b == null) {\n    return true;\n  }\n  return a === b;\n}\n\nfunction sameArray (a, b) {\n  if ((Array.isArray(a) !== Array.isArray(b)) || a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (!sameValue(a[i], b[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction sameStr (a, b) {\n  if (!a && !b) {\n    return true;\n  }\n  return String(a).toLowerCase() === String(b).toLowerCase();\n}\n\nfunction isEquivalent (refA, refB) {\n  // if named, name must match\n  if ((refA.name || refB.name) && refA.name !== refB.name) {\n    return false;\n  }\n  // if structured\n  if ((refA.columns || refB.columns)) {\n    if (refA.table !== refB.table) {\n      return false;\n    }\n    if (!sameArray(refA.columns, refB.columns)) {\n      return false;\n    }\n    if (!sameArray(refA.sections, refB.sections)) {\n      return false;\n    }\n  }\n  // if ranged, range must have the same dimensions (we don't care about $)\n  if (refA.range || refB.range) {\n    if (\n      !sameValue(refA.range.top, refB.range.top) ||\n      !sameValue(refA.range.bottom, refB.range.bottom) ||\n      !sameValue(refA.range.left, refB.range.left) ||\n      !sameValue(refA.range.right, refB.range.right)\n    ) {\n      return false;\n    }\n  }\n  // must have same context\n  if (\n    !sameStr(refA.workbookName, refB.workbookName) ||\n    !sameStr(refA.sheetName, refB.sheetName)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction addContext (ref, sheetName, workbookName) {\n  if (!ref.sheetName) {\n    ref.sheetName = sheetName;\n  }\n  if (!ref.workbookName) {\n    ref.workbookName = workbookName;\n  }\n  return ref;\n}\n\n/**\n * Runs through a list of tokens and adds extra attributes such as matching\n * parens and ranges.\n *\n * The `context` parameter defines default reference attributes:\n * `{ workbookName: 'report.xlsx', sheetName: 'Sheet1' }`.\n * If supplied, these are used to match `A1` to `Sheet1!A1`.\n *\n * All tokens will be tagged with a `.depth` number value to indicating the\n * level of nesting in parentheses as well as an `.index` number indicating\n * their zero based position in the list.\n *\n * The returned output will be the same array of tokens but the following\n * properties will added to tokens (as applicable):\n *\n * #### Parentheses ( )\n *\n * Matching parens will be tagged with `.groupId` string identifier as well as\n * a `.depth` number value (indicating the level of nesting).\n *\n * Closing parens without a counterpart will be tagged with `.error`\n * (boolean true).\n *\n * #### Curly brackets { }\n *\n * Matching curly brackets will be tagged with `.groupId` string identifier.\n * These may not be nested in Excel.\n *\n * Closing curly brackets without a counterpart will be tagged with `.error`\n * (boolean `true`).\n *\n * #### Ranges (`REF_RANGE` or `REF_BEAM` type tokens)\n *\n * All ranges will be tagged with `.groupId` string identifier regardless of\n * the number of times they occur.\n *\n * #### Tokens of type `UNKNOWN`\n *\n * All will be tagged with `.error` (boolean `true`).\n *\n * @param {Array<Token>} tokenlist An array of tokens (from `tokenize()`)\n * @param {object} [context={}] A contest used to match `A1` to `Sheet1!A1`.\n * @param {string} [context.sheetName=''] An implied sheet name ('Sheet1')\n * @param {string} [context.workbookName=''] An implied workbook name ('report.xlsx')\n * @returns {Array<TokenEnhanced>} The input array with the enchanced tokens\n */\nexport function addTokenMeta (tokenlist, { sheetName = '', workbookName = '' } = {}) {\n  const parenStack = [];\n  let arrayStart = null;\n  const uid = getIDer();\n  const knownRefs = [];\n\n  const getCurrDepth = () => parenStack.length + (arrayStart ? 1 : 0);\n\n  tokenlist.forEach((token, i) => {\n    token.index = i;\n    token.depth = getCurrDepth();\n    if (token.value === '(') {\n      parenStack.push(token);\n      token.depth = getCurrDepth();\n    }\n    else if (token.value === ')') {\n      const counter = parenStack.pop();\n      if (counter) {\n        const pairId = uid();\n        token.groupId = pairId;\n        token.depth = counter.depth;\n        counter.groupId = pairId;\n      }\n      else {\n        token.error = true;\n      }\n    }\n    else if (token.value === '{') {\n      if (!arrayStart) {\n        arrayStart = token;\n        token.depth = getCurrDepth();\n      }\n      else {\n        token.error = true;\n      }\n    }\n    else if (token.value === '}') {\n      if (arrayStart) {\n        const pairId = uid();\n        token.groupId = pairId;\n        token.depth = arrayStart.depth;\n        arrayStart.groupId = pairId;\n      }\n      else {\n        token.error = true;\n      }\n      arrayStart = null;\n    }\n    else if (\n      token.type === REF_RANGE ||\n      token.type === REF_BEAM ||\n      token.type === REF_TERNARY ||\n      token.type === REF_STRUCT\n    ) {\n      const ref = (token.type === REF_STRUCT)\n        ? parseStructRef(token.value, { xlsx: true })\n        : parseA1Ref(token.value, { allowTernary: true, xlsx: true });\n      if (ref && (ref.range || ref.columns)) {\n        ref.source = token.value;\n        addContext(ref, sheetName, workbookName);\n        const known = knownRefs.find(d => isEquivalent(d, ref));\n        if (known) {\n          token.groupId = known.groupId;\n        }\n        else {\n          ref.groupId = uid();\n          token.groupId = ref.groupId;\n          knownRefs.push(ref);\n        }\n      }\n    }\n    else if (token.type === UNKNOWN) {\n      token.error = true;\n    }\n  });\n  return tokenlist;\n}\n","/*\n** RC notation works differently from A1 in that we can't merge static\n** references joined by `:`. Merging can only work between references\n** that are relative/absolute on the same axes, so:\n** - R1C1:R2C2 will work,\n** - R[1]C1:R[2]C2 will also work, but\n** - R[1]C[1]:R2C2 doesn't have a direct rectangle represention without context.\n*/\nimport { rangeOperator } from './a1.js';\nimport { MAX_ROWS, MAX_COLS } from './constants.js';\nimport { parseRef } from './parseRef.js';\nimport { stringifyPrefix, stringifyPrefixAlt } from './stringifyPrefix.js';\n\nconst clamp = (min, val, max) => Math.min(Math.max(val, min), max);\n\nfunction toCoord (value, isAbs) {\n  if (isAbs) {\n    return String(value + 1);\n  }\n  return value ? '[' + value + ']' : '';\n}\n\nfunction trimDirection (head, tail) {\n  if (head && tail) {\n    return 'both';\n  }\n  if (head) {\n    return 'head';\n  }\n  if (tail) {\n    return 'tail';\n  }\n}\n\n/**\n * Stringify a range object into R1C1 syntax.\n *\n * @ignore\n * @private\n * @see parseR1C1Ref\n * @param {RangeR1C1} range  A range object\n * @returns {string}  An R1C1-style string represenation of a range\n */\nexport function toR1C1 (range) {\n  let { r0, c0, r1, c1 } = range;\n  const { $c0, $c1, $r0, $r1 } = range;\n  const nullR0 = r0 == null;\n  const nullC0 = c0 == null;\n  let nullR1 = r1 == null;\n  let nullC1 = c1 == null;\n  const op = rangeOperator(range.trim);\n  const hasTrim = !!range.trim;\n  r0 = clamp($r0 ? 0 : -MAX_ROWS, r0 | 0, MAX_ROWS);\n  c0 = clamp($c0 ? 0 : -MAX_COLS, c0 | 0, MAX_COLS);\n  if (!nullR0 && nullR1 && !nullC0 && nullC1) {\n    r1 = r0;\n    nullR1 = false;\n    c1 = c0;\n    nullC1 = false;\n  }\n  else {\n    r1 = clamp($r1 ? 0 : -MAX_ROWS, r1 | 0, MAX_ROWS);\n    c1 = clamp($c1 ? 0 : -MAX_COLS, c1 | 0, MAX_COLS);\n  }\n  // C:C\n  const allRows = r0 === 0 && r1 >= MAX_ROWS;\n  if ((allRows && !nullC0 && !nullC1) || (nullR0 && nullR1)) {\n    const a = toCoord(c0, $c0);\n    const b = toCoord(c1, $c1);\n    return 'C' + (a === b && !hasTrim ? a : a + op + 'C' + b);\n  }\n  // R:R\n  const allCols = c0 === 0 && c1 >= MAX_COLS;\n  if ((allCols && !nullR0 && !nullR1) || (nullC0 && nullC1)) {\n    const a = toCoord(r0, $r0);\n    const b = toCoord(r1, $r1);\n    return 'R' + (a === b && !hasTrim ? a : a + op + 'R' + b);\n  }\n  const s_r0 = toCoord(r0, $r0);\n  const s_r1 = toCoord(r1, $r1);\n  const s_c0 = toCoord(c0, $c0);\n  const s_c1 = toCoord(c1, $c1);\n  // RC:R, RC:C\n  if (nullR0 || nullR1 || nullC0 || nullC1) {\n    return (\n      (nullR0 ? '' : 'R' + s_r0) +\n      (nullC0 ? '' : 'C' + s_c0) +\n      op +\n      (nullR1 ? '' : 'R' + s_r1) +\n      (nullC1 ? '' : 'C' + s_c1)\n    );\n  }\n  // RC:RC\n  if (s_r0 !== s_r1 || s_c0 !== s_c1) {\n    return 'R' + s_r0 + 'C' + s_c0 + op + 'R' + s_r1 + 'C' + s_c1;\n  }\n  // RC\n  return 'R' + s_r0 + 'C' + s_c0;\n}\n\nfunction parseR1C1Part (ref) {\n  let r0 = null;\n  let c0 = null;\n  let $r0 = null;\n  let $c0 = null;\n  // R part\n  const rm = /^R(?:\\[([+-]?\\d+)\\]|(\\d+))?/.exec(ref);\n  if (rm) {\n    if (rm[1]) {\n      r0 = parseInt(rm[1], 10);\n      $r0 = false;\n    }\n    else if (rm[2]) {\n      r0 = parseInt(rm[2], 10) - 1;\n      $r0 = true;\n    }\n    else {\n      r0 = 0;\n      $r0 = false;\n    }\n    ref = ref.slice(rm[0].length);\n  }\n  // C part\n  const cm = /^C(?:\\[([+-]?\\d+)\\]|(\\d+))?/.exec(ref);\n  if (cm) {\n    if (cm[1]) {\n      c0 = parseInt(cm[1], 10);\n      $c0 = false;\n    }\n    else if (cm[2]) {\n      c0 = parseInt(cm[2], 10) - 1;\n      $c0 = true;\n    }\n    else {\n      c0 = 0;\n      $c0 = false;\n    }\n    ref = ref.slice(cm[0].length);\n  }\n  // must have at least one part (and nothing more)\n  if ((!rm && !cm) || ref.length) {\n    return null;\n  }\n  return [ r0, c0, $r0, $c0 ];\n}\n\n/**\n * Parse a simple string reference to an R1C1 range into a range object.\n *\n * @private\n * @ignore\n * @see parseA1Ref\n * @param {string} rangeString  A range string\n * @returns {(RangeR1C1|null)} An object representing a valid reference or null if it is invalid.\n */\nexport function fromR1C1 (rangeString) {\n  let final = null;\n  const [ part1, op, part2, overflow ] = rangeString.split(/(\\.?:\\.?)/);\n  if (overflow) {\n    return null;\n  }\n  const range = parseR1C1Part(part1);\n  // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n  const trim = trimDirection(!!op && op[0] === '.', !!op && op[op.length - 1] === '.');\n  if (range) {\n    const [ r0, c0, $r0, $c0 ] = range;\n    if (part2) {\n      const extendTo = parseR1C1Part(part2);\n      if (extendTo) {\n        final = {};\n        const [ r1, c1, $r1, $c1 ] = extendTo;\n        // rows\n        if (r0 != null && r1 != null) {\n          final.r0 = $r0 === $r1 ? Math.min(r0, r1) : r0;\n          final.$r0 = $r0;\n          final.r1 = $r0 === $r1 ? Math.max(r0, r1) : r1;\n          final.$r1 = $r1;\n        }\n        else if (r0 != null && r1 == null) {\n          // partial RC:C\n          final.r0 = r0;\n          final.$r0 = $r0;\n          final.r1 = null;\n          final.$r1 = $r0;\n        }\n        else if (r0 == null && r1 != null) {\n          // partial C:RC\n          final.r0 = r1;\n          final.$r0 = $r1;\n          final.r1 = null;\n          final.$r1 = $r1;\n        }\n        else if (r0 == null && r1 == null) {\n          // C:C\n          final.r0 = null;\n          final.$r0 = false;\n          final.r1 = null;\n          final.$r1 = false;\n        }\n        // columns\n        if (c0 != null && c1 != null) {\n          final.c0 = $c0 === $c1 ? Math.min(c0, c1) : c0;\n          final.$c0 = $c0;\n          final.c1 = $c0 === $c1 ? Math.max(c0, c1) : c1;\n          final.$c1 = $c1;\n        }\n        else if (c0 != null && c1 == null) {\n          final.c0 = c0;\n          final.$c0 = $c0;\n          final.c1 = null;\n          final.$c1 = $c0;\n        }\n        else if (c0 == null && c1 != null) {\n          final.c0 = c1;\n          final.$c0 = $c1;\n          final.c1 = null;\n          final.$c1 = $c1;\n        }\n        else if (c0 == null && c1 == null) {\n          final.c0 = null;\n          final.$c0 = false;\n          final.c1 = null;\n          final.$c1 = false;\n        }\n      }\n      else {\n        return null;\n      }\n    }\n    // range only - no second part\n    else if (r0 != null && c0 == null) {\n      final = {\n        r0: r0,\n        c0: null,\n        r1: r0,\n        c1: null,\n        $r0: $r0,\n        $c0: false,\n        $r1: $r0,\n        $c1: false\n      };\n    }\n    else if (r0 == null && c0 != null) {\n      final = {\n        r0: null,\n        c0: c0,\n        r1: null,\n        c1: c0,\n        $r0: false,\n        $c0: $c0,\n        $r1: false,\n        $c1: $c0\n      };\n    }\n    else {\n      final = {\n        r0: r0 || 0,\n        c0: c0 || 0,\n        r1: r0 || 0,\n        c1: c0 || 0,\n        $r0: $r0 || false,\n        $c0: $c0 || false,\n        $r1: $r0 || false,\n        $c1: $c0 || false\n      };\n    }\n  }\n  if (final && trim) {\n    final.trim = trim;\n  }\n  return final;\n}\n\n/**\n * Parse a string reference into an object representing it.\n *\n * ```js\n * parseR1C1Ref('Sheet1!R[9]C9:R[9]C9');\n * // => {\n * //   context: [ 'Sheet1' ],\n * //   range: {\n * //     r0: 9,\n * //     c0: 8,\n * //     r1: 9,\n * //     c1: 8,\n * //     $c0: true,\n * //     $c1: true\n * //     $r0: false,\n * //     $r1: false\n * //   }\n * // }\n * ```\n *\n * @param {string} refString An R1C1-style reference string\n * @param {object} [options={}]  Options\n * @param {boolean} [options.allowNamed=true]  Enable parsing names as well as ranges.\n * @param {boolean} [options.allowTernary=false]  Enables the recognition of ternary ranges in the style of `A1:A` or `A1:1`. These are supported by Google Sheets but not Excel. See: References.md.\n * @param {boolean} [options.xlsx=false]  Switches to the `[1]Sheet1!A1` or `[1]!name` prefix syntax form for external workbooks. See: [Prefixes.md](./Prefixes.md)\n * @returns {(ReferenceR1C1|null)} An object representing a valid reference or null if it is invalid.\n */\nexport function parseR1C1Ref (refString, { allowNamed = true, allowTernary = false, xlsx = false } = {}) {\n  const d = parseRef(refString, { allowNamed, allowTernary, xlsx, r1c1: true });\n  if (d && (d.r0 || d.name)) {\n    const range = d.r1\n      ? fromR1C1(d.r0 + d.operator + d.r1)\n      : fromR1C1(d.r0);\n    if (range) {\n      return xlsx\n        ? { workbookName: d.workbookName, sheetName: d.sheetName, range }\n        : { context: d.context, range };\n    }\n    if (d.name) {\n      return xlsx\n        ? { workbookName: d.workbookName, sheetName: d.sheetName, name: d.name }\n        : { context: d.context, name: d.name };\n    }\n    return null;\n  }\n  return null;\n}\n\n/**\n * Get an R1C1-style string representation of a reference object.\n *\n * ```js\n * stringifyR1C1Ref({\n *   context: [ 'Sheet1' ],\n *   range: {\n *     r0: 9,\n *     c0: 8,\n *     r1: 9,\n *     c1: 8,\n *     $c0: true,\n *     $c1: true\n *     $r0: false,\n *     $r1: false\n *   }\n * });\n * // => 'Sheet1!R[9]C9:R[9]C9'\n * ```\n *\n * @param {ReferenceR1C1} refObject A reference object\n * @param {object} [options={}]  Options\n * @param {boolean} [options.xlsx=false]  Switches to the `[1]Sheet1!A1` or `[1]!name` prefix syntax form for external workbooks. See: [Prefixes.md](./Prefixes.md)\n * @returns {string} The reference in R1C1-style string format\n */\nexport function stringifyR1C1Ref (refObject, { xlsx = false } = {}) {\n  const prefix = xlsx\n    ? stringifyPrefixAlt(refObject)\n    : stringifyPrefix(refObject);\n  return prefix + (\n    refObject.name ? refObject.name : toR1C1(refObject.range)\n  );\n}\n","import { MAX_ROWS, MAX_COLS, ERROR } from './constants.js';\nimport { parseA1Ref, stringifyA1Ref } from './a1.js';\nimport { parseR1C1Ref, stringifyR1C1Ref } from './rc.js';\nimport { tokenize } from './lexer.js';\nimport { isRange } from './isType.js';\nimport { fromA1 } from './fromA1.js';\n\nconst calc = (abs, vX, aX) => {\n  if (vX == null) {\n    return null;\n  }\n  return abs ? vX : vX - aX;\n};\n\nfunction tokensToString (tokens) {\n  let s = '';\n  for (const token of tokens) {\n    s += token.value;\n  }\n  return s;\n}\n\nfunction cloneToken (token) {\n  // Token\n  const newToken = {\n    type: token.type,\n    value: token.value\n  };\n  if (token.loc) {\n    newToken.loc = token.loc;\n  }\n  if (token.unterminated != null) {\n    newToken.unterminated = token.unterminated;\n  }\n  // TokenEnhanced\n  if (token.index != null) {\n    newToken.index = token.index;\n    if (token.groupId) {\n      newToken.groupId = token.groupId;\n    }\n    if (token.depth != null) {\n      newToken.depth = token.depth;\n    }\n    if (token.error) {\n      newToken.error = token.error;\n    }\n  }\n  return newToken;\n}\n\n/**\n * Translates ranges in a formula or list of tokens from absolute A1 syntax to\n * relative R1C1 syntax.\n *\n * ```js\n * translateToR1C1(\"=SUM(E10,$E$2,Sheet!$E$3)\", \"D10\");\n * // => \"=SUM(RC[1],R2C5,Sheet!R3C5)\");\n * ```\n *\n * @param {(string | Array<Token>)} formula A string (an Excel formula) or a token list that should be adjusted.\n * @param {string} anchorCell A simple string reference to an A1 cell ID (`AF123` or`$C$5`).\n * @param {object} [options={}] The options\n * @param {boolean} [options.xlsx=false]  Switches to the `[1]Sheet1!A1` or `[1]!name` prefix syntax form for external workbooks. See: [Prefixes.md](./Prefixes.md)\n * @param {boolean} [options.allowTernary=true]  Enables the recognition of ternary ranges in the style of `A1:A` or `A1:1`. These are supported by Google Sheets but not Excel. See: References.md.\n * @returns {(string | Array<Token>)} A formula string or token list (depending on which was input)\n */\nexport function translateToR1C1 (formula, anchorCell, { xlsx = false, allowTernary = true } = {}) {\n  const anchorRange = fromA1(anchorCell);\n  if (!anchorRange) {\n    throw new Error('translateToR1C1 got an invalid anchorCell: ' + anchorCell);\n  }\n  const { top, left } = anchorRange;\n  const isString = typeof formula === 'string';\n\n  const tokens = isString\n    ? tokenize(formula, { withLocation: false, mergeRefs: false, r1c1: false, xlsx, allowTernary })\n    : formula;\n\n  let offsetSkew = 0;\n  const refOpts = { xlsx, allowTernary };\n  const outTokens = [];\n  for (let token of tokens) {\n    if (isRange(token)) {\n      token = cloneToken(token);\n      const tokenValue = token.value;\n      const ref = parseA1Ref(tokenValue, refOpts);\n      const d = ref.range;\n      const range = {};\n      range.r0 = calc(d.$top, d.top, top);\n      range.r1 = calc(d.$bottom, d.bottom, top);\n      range.c0 = calc(d.$left, d.left, left);\n      range.c1 = calc(d.$right, d.right, left);\n      range.$r0 = d.$top;\n      range.$r1 = d.$bottom;\n      range.$c0 = d.$left;\n      range.$c1 = d.$right;\n      if (d.trim) {\n        range.trim = d.trim;\n      }\n      ref.range = range;\n      token.value = stringifyR1C1Ref(ref, refOpts);\n      // if token includes offsets, those offsets are now likely wrong!\n      if (token.loc) {\n        token.loc[0] += offsetSkew;\n        offsetSkew += token.value.length - tokenValue.length;\n        token.loc[1] += offsetSkew;\n      }\n    }\n    else if (offsetSkew && token.loc && !isString) {\n      token = cloneToken(token);\n      token.loc[0] += offsetSkew;\n      token.loc[1] += offsetSkew;\n    }\n    outTokens[outTokens.length] = token;\n  }\n\n  return isString\n    ? tokensToString(outTokens)\n    : outTokens;\n}\n\nfunction toFixed (val, abs, base, max, wrapEdges = true) {\n  let v = val;\n  if (v != null && !abs) {\n    v = base + val;\n    // Excel \"wraps around\" when value goes out of lower bounds.\n    // It's a bit quirky on entry as Excel _really wants_ to re-rewite the\n    // references but the behaviour is consistent with INDIRECT:\n    // ... In A1: RC[-1] => R1C[16383].\n    if (v < 0) {\n      if (!wrapEdges) {\n        return NaN;\n      }\n      v = max + v + 1;\n    }\n    // ... In B1: =RC[16383] => =RC[-1]\n    if (v > max) {\n      if (!wrapEdges) {\n        return NaN;\n      }\n      v -= max + 1;\n    }\n  }\n  return v;\n}\n\n/**\n * Translates ranges in a formula or list of tokens from relative R1C1 syntax to\n * absolute A1 syntax.\n *\n * ```js\n * translateToA1(\"=SUM(RC[1],R2C5,Sheet!R3C5)\", \"D10\");\n * // => \"=SUM(E10,$E$2,Sheet!$E$3)\");\n * ```\n *\n * If an input range is -1,-1 relative rows/columns and the anchor is A1, the\n * resulting range will (by default) wrap around to the bottom of the sheet\n * resulting in the range XFD1048576. This may not be what you want so may set\n * `wrapEdges` to false which will instead turn the range into a `#REF!` error.\n *\n * ```js\n * translateToA1(\"=R[-1]C[-1]\", \"A1\");\n * // => \"=XFD1048576\");\n *\n * translateToA1(\"=R[-1]C[-1]\", \"A1\", { wrapEdges: false });\n * // => \"=#REF!\");\n * ```\n *\n * Note that if you are passing in a list of tokens that was not created using\n * `mergeRefs` and you disable edge wrapping (or you simply set both options\n * to false), you can end up with a formula such as `=#REF!:B2` or\n * `=Sheet3!#REF!:F3`. These are valid formulas in the Excel formula language\n * and Excel will accept them, but they are not supported in Google Sheets.\n *\n * @param {(string | Array<Token>)} formula A string (an Excel formula) or a token list that should be adjusted.\n * @param {string} anchorCell A simple string reference to an A1 cell ID (`AF123` or`$C$5`).\n * @param {object} [options={}] The options\n * @param {boolean} [options.wrapEdges=true]  Wrap out-of-bounds ranges around sheet edges rather than turning them to #REF! errors\n * @param {boolean} [options.mergeRefs=true]   Should ranges be treated as whole references (`Sheet1!A1:B2`) or as separate tokens for each part: (`Sheet1`,`!`,`A1`,`:`,`B2`).\n * @param {boolean} [options.xlsx=false]  Switches to the `[1]Sheet1!A1` or `[1]!name` prefix syntax form for external workbooks. See: [Prefixes.md](./Prefixes.md)\n * @param {boolean} [options.allowTernary=true]  Enables the recognition of ternary ranges in the style of `A1:A` or `A1:1`. These are supported by Google Sheets but not Excel. See: References.md.\n * @returns {(string | Array<Token>)} A formula string or token list (depending on which was input)\n */\nexport function translateToA1 (formula, anchorCell, options = {}) {\n  const anchorRange = fromA1(anchorCell);\n  if (!anchorRange) {\n    throw new Error('translateToR1C1 got an invalid anchorCell: ' + anchorCell);\n  }\n  const { top, left } = anchorRange;\n  const isString = typeof formula === 'string';\n  const {\n    wrapEdges = true,\n    mergeRefs = true,\n    allowTernary = true,\n    xlsx = false\n  } = options;\n\n  const tokens = isString\n    ? tokenize(formula, {\n      withLocation: false,\n      mergeRefs: mergeRefs,\n      xlsx: xlsx,\n      allowTernary: allowTernary,\n      r1c1: true\n    })\n    : formula;\n\n  let offsetSkew = 0;\n  const refOpts = { xlsx: xlsx, allowTernary: allowTernary };\n  const outTokens = [];\n  for (let token of tokens) {\n    if (isRange(token)) {\n      token = cloneToken(token);\n      const tokenValue = token.value;\n      const ref = parseR1C1Ref(tokenValue, refOpts);\n      const d = ref.range;\n      const range = {};\n      const r0 = toFixed(d.r0, d.$r0, top, MAX_ROWS, wrapEdges);\n      const r1 = toFixed(d.r1, d.$r1, top, MAX_ROWS, wrapEdges);\n      if (r0 > r1) {\n        range.top = r1;\n        range.$top = d.$r1;\n        range.bottom = r0;\n        range.$bottom = d.$r0;\n      }\n      else {\n        range.top = r0;\n        range.$top = d.$r0;\n        range.bottom = r1;\n        range.$bottom = d.$r1;\n      }\n      const c0 = toFixed(d.c0, d.$c0, left, MAX_COLS, wrapEdges);\n      const c1 = toFixed(d.c1, d.$c1, left, MAX_COLS, wrapEdges);\n      if (c0 > c1) {\n        range.left = c1;\n        range.$left = d.$c1;\n        range.right = c0;\n        range.$right = d.$c0;\n      }\n      else {\n        range.left = c0;\n        range.$left = d.$c0;\n        range.right = c1;\n        range.$right = d.$c1;\n      }\n      if (d.trim) {\n        range.trim = d.trim;\n      }\n      if (isNaN(r0) || isNaN(r1) || isNaN(c0) || isNaN(c1)) {\n        // convert to ref error\n        token.type = ERROR;\n        token.value = '#REF!';\n        delete token.groupId;\n      }\n      else {\n        ref.range = range;\n        token.value = stringifyA1Ref(ref, refOpts);\n      }\n      // if token includes offsets, those offsets are now likely wrong!\n      if (token.loc) {\n        token.loc[0] += offsetSkew;\n        offsetSkew += token.value.length - tokenValue.length;\n        token.loc[1] += offsetSkew;\n      }\n    }\n    else if (offsetSkew && token.loc && !isString) {\n      token = cloneToken(token);\n      token.loc[0] += offsetSkew;\n      token.loc[1] += offsetSkew;\n    }\n    outTokens[outTokens.length] = token;\n  }\n\n  return isString\n    ? tokensToString(outTokens)\n    : outTokens;\n}\n","import { stringifyPrefix, stringifyPrefixAlt } from './stringifyPrefix.js';\n\nfunction quoteColname (str) {\n  return str.replace(/([[\\]#'@])/g, '\\'$1');\n}\n\nfunction needsBraces (str) {\n  return !/^[a-zA-Z0-9\\u00a1-\\uffff]+$/.test(str);\n}\n\nfunction toSentenceCase (str) {\n  return str[0].toUpperCase() + str.slice(1).toLowerCase();\n}\n\n/**\n * Get a string representation of a structured reference object.\n *\n * ```js\n * stringifyStructRef({\n *   context: [ 'workbook.xlsx' ],\n *   sections: [ 'data' ],\n *   columns: [ 'my column', '@foo' ],\n *   table: 'tableName',\n * });\n * // => 'workbook.xlsx!tableName[[#Data],[Column1]:[Column2]]'\n * ```\n *\n * @param {ReferenceStruct} refObject A structured reference object\n * @param {object} [options={}]  Options\n * @param {boolean} [options.xlsx=false]  Switches to the `[1]Sheet1!A1` or `[1]!name` prefix syntax form for external workbooks. See: [Prefixes.md](./Prefixes.md)\n * @param {boolean} [options.thisRow=false]  Enforces using the `[#This Row]` instead of the `@` shorthand when serializing structured ranges.\n * @returns {string} The structured reference in string format\n */\nexport function stringifyStructRef (refObject, options = {}) {\n  const { xlsx, thisRow } = options;\n  let s = xlsx\n    ? stringifyPrefixAlt(refObject)\n    : stringifyPrefix(refObject);\n\n  if (refObject.table) {\n    s += refObject.table;\n  }\n  const numColumns = refObject.columns?.length ?? 0;\n  const numSections = refObject.sections?.length ?? 0;\n  // single section\n  if (numSections === 1 && !numColumns) {\n    s += `[#${toSentenceCase(refObject.sections[0])}]`;\n  }\n  // single column\n  else if (!numSections && numColumns === 1) {\n    s += `[${quoteColname(refObject.columns[0])}]`;\n  }\n  else {\n    s += '[';\n    // single [#this row] sections get normalized to an @ by default\n    const singleAt = !thisRow && numSections === 1 && refObject.sections[0].toLowerCase() === 'this row';\n    if (singleAt) {\n      s += '@';\n    }\n    else if (numSections) {\n      s += refObject.sections\n        .map(d => `[#${toSentenceCase(d)}]`)\n        .join(',');\n      if (numColumns) {\n        s += ',';\n      }\n    }\n    // a case of a single alphanumberic column with a [#this row] becomes [@col]\n    if (singleAt && refObject.columns.length === 1 && !needsBraces(refObject.columns[0])) {\n      s += quoteColname(refObject.columns[0]);\n    }\n    else if (numColumns) {\n      s += refObject.columns.slice(0, 2)\n        .map(d => (`[${quoteColname(d)}]`))\n        .join(':');\n    }\n    s += ']';\n  }\n  return s;\n}\n","import { isRange } from './isType.js';\nimport { parseA1Ref, stringifyA1Ref, addA1RangeBounds } from './a1.js';\nimport { parseStructRef } from './parseStructRef.js';\nimport { stringifyStructRef } from './stringifyStructRef.js';\nimport { tokenize } from './lexer.js';\nimport { REF_STRUCT } from './constants.js';\n\n// There is no R1C1 counterpart to this. This is because without an anchor cell\n// it is impossible to determine if a relative+absolute range (R[1]C[1]:R5C5)\n// needs to be flipped or not. The solution is to convert to A1 first:\n// translateToRC(fixRanges(translateToA1(...)))\n\n/**\n * Normalizes A1 style ranges and structured references in a formula or list of\n * tokens.\n *\n * It ensures that that the top and left coordinates of an A1 range are on the\n * left-hand side of a colon operator:\n *\n * ```\n * B2:A1 → A1:B2\n * 1:A1 → A1:1\n * A:A1 → A1:A\n * B:A → A:B\n * 2:1 → 1:2\n * A1:A1 → A1\n * ```\n *\n * When `{ addBounds: true }` is passed as an option, the missing bounds are\n * also added. This can be done to ensure Excel compatible ranges. The fixes\n * then additionally include:\n *\n * ```\n * 1:A1 → A1:1 → 1:1\n * A:A1 → A1:A → A:A\n * A1:A → A:A\n * A1:1 → A:1\n * B2:B → B2:1048576\n * B2:2 → B2:XFD2\n * ```\n *\n * Structured ranges are normalized cleaned up to have consistent order and\n * capitalization of sections as well as removing redundant ones.\n *\n * Returns the same formula with the ranges updated. If an array of tokens was\n * supplied, then a new array is returned.\n *\n * @param {(string | Array<Token>)} formula A string (an Excel formula) or a token list that should be adjusted.\n * @param {object} [options={}]  Options\n * @param {boolean} [options.addBounds=false]  Fill in any undefined bounds of range objects. Top to 0, bottom to 1048575, left to 0, and right to 16383.\n * @param {boolean} [options.xlsx=false]  Switches to the `[1]Sheet1!A1` or `[1]!name` prefix syntax form for external workbooks. See: [Prefixes.md](./Prefixes.md)\n * @param {boolean} [options.thisRow=false]  Enforces using the `[#This Row]` instead of the `@` shorthand when serializing structured ranges.\n * @returns {(string | Array<Token>)} A formula string or token list (depending on which was input)\n */\nexport function fixRanges (formula, options = { addBounds: false }) {\n  if (typeof formula === 'string') {\n    return fixRanges(tokenize(formula, options), options)\n      .map(d => d.value)\n      .join('');\n  }\n  if (!Array.isArray(formula)) {\n    throw new Error('fixRanges expects an array of tokens');\n  }\n  const { addBounds, r1c1, xlsx, thisRow } = options;\n  if (r1c1) {\n    throw new Error('fixRanges does not have an R1C1 mode');\n  }\n  let offsetSkew = 0;\n  return formula.map(t => {\n    const token = { ...t };\n    if (t.loc) {\n      token.loc = [ ...t.loc ];\n    }\n    let offsetDelta = 0;\n    if (token.type === REF_STRUCT) {\n      const sref = parseStructRef(token.value, { xlsx });\n      const newValue = stringifyStructRef(sref, { xlsx, thisRow });\n      offsetDelta = newValue.length - token.value.length;\n      token.value = newValue;\n    }\n    else if (isRange(token)) {\n      const ref = parseA1Ref(token.value, { xlsx, allowTernary: true });\n      const range = ref.range;\n      // fill missing dimensions?\n      if (addBounds) {\n        addA1RangeBounds(range);\n      }\n      const newValue = stringifyA1Ref(ref, { xlsx });\n      offsetDelta = newValue.length - token.value.length;\n      token.value = newValue;\n    }\n    // ensure that positioning is still correct\n    if (offsetSkew || offsetDelta) {\n      if (token.loc) {\n        token.loc[0] += offsetSkew;\n      }\n      offsetSkew += offsetDelta;\n      if (token.loc) {\n        token.loc[1] += offsetSkew;\n      }\n    }\n    else {\n      offsetSkew += offsetDelta;\n    }\n    return token;\n  });\n}\n\n","/**\n * Convert a column string representation to a 0 based\n * offset number (`\"C\"` = `2`).\n *\n * The method expects a valid column identifier made up of _only_\n * A-Z letters, which may be either upper or lower case. Other input will\n * return garbage.\n *\n * @param {string} columnString  The column string identifier\n * @returns {number}  Zero based column index number\n */\nexport function fromCol (columnString) {\n  const x = (columnString || '');\n  const l = x.length;\n  let n = 0;\n  if (l > 2) {\n    const c = x.charCodeAt(l - 3);\n    const a = c > 95 ? 32 : 0;\n    n += (1 + c - a - 65) * 676;\n  }\n  if (l > 1) {\n    const c = x.charCodeAt(l - 2);\n    const a = c > 95 ? 32 : 0;\n    n += (1 + c - a - 65) * 26;\n  }\n  if (l) {\n    const c = x.charCodeAt(l - 1);\n    const a = c > 95 ? 32 : 0;\n    n += (c - a) - 65;\n  }\n  return n;\n}\n","export { tokenize } from './lexer.js';\nexport { parse } from './parser.js';\nexport { addTokenMeta } from './addTokenMeta.js';\nexport { translateToR1C1, translateToA1 } from './translate.js';\nexport { MAX_COLS, MAX_ROWS } from './constants.js';\nexport { mergeRefTokens } from './mergeRefTokens.js';\nexport { fixRanges } from './fixRanges.js';\nexport {\n  isError,\n  isFunction,\n  isFxPrefix,\n  isLiteral,\n  isOperator,\n  isRange,\n  isReference,\n  isWhitespace\n} from './isType.js';\n\nexport { fromCol } from './fromCol.js';\nexport { toCol } from './toCol.js';\n\nexport {\n  parseA1Ref,\n  stringifyA1Ref,\n  addA1RangeBounds\n} from './a1.js';\n\nexport {\n  parseR1C1Ref,\n  stringifyR1C1Ref\n} from './rc.js';\n\nexport { stringifyStructRef } from './stringifyStructRef.js';\nexport { parseStructRef } from './parseStructRef.js';\n\nimport {\n  // token types\n  OPERATOR,\n  BOOLEAN,\n  ERROR,\n  NUMBER,\n  FUNCTION,\n  NEWLINE,\n  WHITESPACE,\n  STRING,\n  CONTEXT,\n  CONTEXT_QUOTE,\n  REF_RANGE,\n  REF_BEAM,\n  REF_TERNARY,\n  REF_NAMED,\n  REF_STRUCT,\n  FX_PREFIX,\n  UNKNOWN,\n  // AST types\n  UNARY,\n  BINARY,\n  REFERENCE,\n  LITERAL,\n  ERROR_LITERAL,\n  CALL,\n  ARRAY,\n  IDENTIFIER\n} from './constants.js';\n\n/**\n * A dictionary of the types used to identify token variants.\n *\n * @readonly\n * @constant {Object<string>} tokenTypes\n * @property {string} OPERATOR - Newline (`\\n`)\n * @property {string} BOOLEAN - Boolean literal (`TRUE`)\n * @property {string} ERROR - Error literal (`#VALUE!`)\n * @property {string} NUMBER - Number literal (`123.4`, `-1.5e+2`)\n * @property {string} FUNCTION - Function name (`SUM`)\n * @property {string} NEWLINE - Newline character (`\\n`)\n * @property {string} WHITESPACE - Whitespace character sequence (` `)\n * @property {string} STRING - String literal (`\"Lorem ipsum\"`)\n * @property {string} CONTEXT - Reference context ([Workbook.xlsx]Sheet1)\n * @property {string} CONTEXT_QUOTE - Quoted reference context (`'[My workbook.xlsx]Sheet1'`)\n * @property {string} REF_RANGE - A range identifier (`A1`)\n * @property {string} REF_BEAM - A range \"beam\" identifier (`A:A` or `1:1`)\n * @property {string} REF_TERNARY - A ternary range identifier (`B2:B`)\n * @property {string} REF_NAMED - A name / named range identifier (`income`)\n * @property {string} REF_STRUCT - A structured reference identifier (`table[[Column1]:[Column2]]`)\n * @property {string} FX_PREFIX - A leading equals sign at the start of a formula (`=`)\n * @property {string} UNKNOWN - Any unidentifiable range of characters.\n * @see tokenize\n */\nexport const tokenTypes = Object.freeze({\n  OPERATOR,\n  BOOLEAN,\n  ERROR,\n  NUMBER,\n  FUNCTION,\n  NEWLINE,\n  WHITESPACE,\n  STRING,\n  CONTEXT,\n  CONTEXT_QUOTE,\n  REF_RANGE,\n  REF_BEAM,\n  REF_TERNARY,\n  REF_NAMED,\n  REF_STRUCT,\n  FX_PREFIX,\n  UNKNOWN\n});\n\n/**\n * A dictionary of the types used to identify AST node variants.\n *\n * @readonly\n * @constant {Object<string>} nodeTypes\n * @property {string} UNARY - A unary operation (`10%`)\n * @property {string} BINARY - A binary operation (`10+10`)\n * @property {string} REFERENCE - A range identifier (`A1`)\n * @property {string} LITERAL - A literal (number, string, or boolean) (`123`, `\"foo\"`, `false`)\n * @property {string} ERROR - An error literal (`#VALUE!`)\n * @property {string} CALL - A function call expression (`SUM(1,2)`)\n * @property {string} ARRAY - An array expression (`{1,2;3,4}`)\n * @property {string} IDENTIFIER - A function name identifier (`SUM`)\n * @see parse\n */\nexport const nodeTypes = Object.freeze({\n  UNARY,\n  BINARY,\n  REFERENCE,\n  LITERAL,\n  ERROR: ERROR_LITERAL,\n  CALL,\n  ARRAY,\n  IDENTIFIER\n});\n"],"mappings":"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","names":["tokens","PERIOD","COLON","BR_OPEN","BR_CLOSE","c","BR_CLOSE","BR_OPEN","COLON","HASH","QUOT_SINGLE","EXCL","EXCL","tokens","END","FUNCTION","WHITESPACE","tokens","parse","advRangeOp","advA1Col","advA1Row","prefix","clamp","prefix","tokens"]}